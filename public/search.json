[{"categories":["WPF"],"content":"WPF 布局控件（继承自 Panel 类, 除了Border）通过测量（Measure）和排列（Arrange）两个阶段自动计算子元素的位置与尺寸，支持动态适应窗口大小变化。布局控件通过 Children 属性容纳子元素（如按钮、文本框等），支持嵌套组合实现复杂界面。 控件 布局方式 Grid 网格，根据自定义行和列来设置控件的布局 StackPanel 堆叠，包含的元素在垂直或水平方向排列 WrapPanel 流式布局，自动换行/列 DockPanel 边缘停靠+剩余填充 Canvas 画布，内部元素以像素为单位绝对坐标定位 UniformGrid 均分网格，相当于Grid的简化版，每个单元格的大小相同 Border 装饰的控件，用于绘制边框及背景，在Border中只能有一个子控件 Panel基类\rPanel 是 Windows Presentation Foundation（WPF）中提供布局支持的所有元素的基类。 Panel派生元素用于在可扩展应用程序标记语言（XAML）和代码中定位和排列元素。 WPF 包含一套全面的派生面板实现，可实现许多复杂布局。 这些派生类公开了启用大多数标准用户界面（UI）方案的属性和方法。 无法找到满足其需求的子排列行为的开发人员可以通过重写 ArrangeOverride 和 MeasureOverride 方法创建新的布局。 所有Panel元素都支持由FrameworkElement定义的基本大小调整和定位属性，包括Height、Width、HorizontalAlignment、VerticalAlignment和MarginLayoutTransform。 有关定位属性 FrameworkElement的其他信息，请参阅 对齐、边距和填充概述。 Panel 公开了在理解和使用布局时极为重要的附加属性。 该Background属性用于用一个Brush填充派生面板元素的边界之间的区域。 Children 表示由其 Panel 构成的元素的子集合。 InternalChildren 表示集合的内容 Children 以及数据绑定生成的成员。 两者都由父级UIElementCollection托管的子元素组成Panel。 面板还公开了一个 Panel.ZIndex 附加属性，该属性可用于在派生 Panel中实现分层顺序。 具有较高Children值的面板Panel.ZIndex集合的成员显示在值较低的Panel.ZIndex集合前面。 这对于面板特别有用，例如CanvasGrid，允许子元素共享相同的坐标空间。 Panel 还定义了 OnRender 方法，该方法可用于替代默认 Panel呈现行为。 Panel提供了GetZIndex和SetZIndex方法成员，分别表示获取某个元素的Zindex顺序和设置某个元素的ZIndex顺序。 什么是ZIndex?这是Panel提供的一个附加属性。假如一个单行单列的Grid布局控件中有两个Button,正常情况下，这两个Button都会以撑满Grid的方式星现在Grid中，那么，到底哪一个Button在上面，哪一个Button在下面呢?就看这两个Button的Panel.ZIndex附加属性的值，值越大越在上面，而值较小的那个Button将被上面的Button遮盖，从而在视觉上，用户只能看到一个Button。 Grid(网格布局)\r通过行（RowDefinitions）和列（ColumnDefinitions）定义表格结构，支持单元格合并与动态尺寸调整。 关键属性： Grid.Row / Grid.Column：指定子元素位置。 RowSpan / ColumnSpan：跨行/列。 ShowGridLines: 是否显示网格线 Grid的列宽与行高可采用固定、自动、按比例三种方式定义。 固定长度：值为一个确定的数字 自动长度：值为Auto，实际作用就是取实际控件所需的最小值 比例长度： *表示占用剩余的全部宽度；两行都是*，将平分剩余宽度; 一个2*，一个*，则前者占剩余全部宽度的2/3，后者占1/3; 示例： \u003cGrid\u003e \u003cGrid.RowDefinitions\u003e \u003c!--设置4行--\u003e \u003cRowDefinition Height=\"40\"\u003e\u003c/RowDefinition\u003e \u003cRowDefinition Height=\"Auto\"\u003e\u003c/RowDefinition\u003e \u003cRowDefinition Height=\"2*\"\u003e\u003c/RowDefinition\u003e \u003cRowDefinition Height=\"*\"\u003e\u003c/RowDefinition\u003e \u003c/Grid.RowDefinitions\u003e \u003cButton Grid.Row=\"0\" Content=\"Button 1\"\u003e\u003c/Button\u003e \u003cButton Grid.Row=\"1\" Content=\"Button 2\"\u003e\u003c/Button\u003e \u003cButton Grid.Row=\"2\" Content=\"Button 3\"\u003e\u003c/Button\u003e \u003cButton Grid.Row=\"3\" Content=\"Button 4\"\u003e\u003c/Button\u003e \u003c/Grid\u003e 效果： StackPanel(堆叠布局)\r子元素按单一方向（Orientation=\"Vertical\" 或 Horizontal\"）线性排列，不自动换行。默认方向是垂直排列（Orientation=\"Vertical\"），子元素从上到下堆叠。如果要设置水平排列，设置 Orientation=\"Horizontal\"，子元素从左到右排列。垂直布局时，子元素宽度默认拉伸至 StackPanel 的宽度，高度由内容决定（或显式设置）。水平布局时，子元素高度拉伸至 StackPanel 高度，宽度由内容决定。 StackPanel关键属性如下： 属性 说明 示例值 Orientation 排列方向：Vertical（默认）或 Horizontal Orientation=\"Horizontal\" Margin 容器外间距，控制与父容器的距离 Margin=\"10\" Padding 容器内边距，控制子元素与容器边界的距离 Padding=\"5\" Background 背景色（未设置时不响应鼠标事件） Background=\"LightGray\" HorizontalAlignment 容器在父容器中的水平对齐方式（Left/Center/Right/Stretch） HorizontalAlignment=\"Center\" VerticalAlignment 容器在父容器中的垂直对齐方式（Top/Center/Bottom/Stretch） VerticalAlignment=\"Top\" 布局嵌套\rStackPanel 可嵌套其他容器（如 Grid、嵌套的 StackPanel）实现复杂结构 \u003c!-- 垂直布局嵌套水平布局 --\u003e \u003cStackPanel Orientation=\"Vertical\"\u003e \u003cTextBlock Text=\"用户登录\"/\u003e \u003cStackPanel Orientation=\"Horizontal\"\u003e \u003c!-- 水平布局 --\u003e \u003cTextBlock Text=\"用户名：\" VerticalAlignment=\"Center\"/\u003e \u003cTextBox Width=\"200\"/\u003e \u003c/StackPanel\u003e \u003cButton Content=\"提交\"/\u003e \u003c/StackPanel\u003e 滚动支持\r通过 ScrollViewer 包裹 StackPanel 解决内容溢出问题 \u003cScrollViewer Height=\"150\"\u003e \u003cStackPanel\u003e \u003cButton Content=\"Item 1\" Height=\"40\"/\u003e \u003c!-- 更多子元素 --\u003e \u003c/StackPanel\u003e \u003c/ScrollViewer\u003e 动态操作子元素\r在代码中动态添加/删除子元素 // 添加按钮 private void AddButton_Click(object sender, RoutedEventArgs e) { Button newBtn = new Button { Content = \"New Button\" }; stackPanel.Children.Add(newBtn); } // 删除最后一个按钮 private void RemoveButton_Click(object sender, RoutedEventArgs e) { if (stackPanel.Children.Count \u003e 0) stackPanel.Children.RemoveAt(stackPanel.Children.Count - 1); } WrapPanel(流式布局)\rWrapPanel与StackPanel类似的功能, 相对于WrapPanel , 具有在有限的容器范围内, 可以自动换行, 或者换列处理。 具体则取决于WrapPanel的排列方式 (Orientation)： Orientation=\"Horizontal\"时各控件从左至右排列，当面板长度不够时，子控件就会自动换行，继续按照从左至右的顺序排列 Orientation=\"Vertical\"时各控件从上至下排列，当面板高度不够时，子控件就会自动换列，继续按照从上至下的顺序排列 示例： \u003cWrapPanel Orientation=\"Horizontal\"\u003e \u003cButton Content=\"Button 150\" Wid","date":"2025-08-05","objectID":"/csharp/wpf/64d18599-4cf7-40aa-b995-9cc111f50bd3/:0:0","tags":["WPF","C#"],"title":"WPF布局控件","uri":"/csharp/wpf/64d18599-4cf7-40aa-b995-9cc111f50bd3/"},{"categories":["C#基础"],"content":"1. 什么是数据类型？\r数据类型定义了变量可以存储的数据种类、占用内存的大小以及可以对变量执行的操作。C# 中的数据类型主要分为两类： 值类型 (Value Types)：直接存储数据，如整数、浮点数、布尔值等。 引用类型 (Reference Types)：存储数据的引用（内存地址），如字符串、数组、类等。 2. 值类型 (Value Types)\r值类型变量直接在栈内存中存储实际数据。以下是常见的内置值类型： 2.1 整数类型\r整数类型用于存储没有小数部分的数字。C# 提供多种整数类型，区别在于大小和是否支持负数： 类型 占用字节 范围 描述 byte 1 0 到 255 无符号 8 位整数 sbyte 1 -128 到 127 有符号 8 位整数 short 2 -32,768 到 32,767 有符号 16 位整数 ushort 2 0 到 65,535 无符号 16 位整数 int 4 -2,147,483,648 到 2,147,483,647 有符号 32 位整数 uint 4 0 到 4,294,967,295 无符号 32 位整数 long 8 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 有符号 64 位整数 ulong 8 0 到 18,446,744,073,709,551,615 无符号 64 位整数 示例代码： int age = 25; long bigNumber = 1234567890123L; // 使用 L 表示 long 类型 byte smallNumber = 255; 2.2 浮点类型\r浮点类型用于存储带小数部分的数字，适用于需要高精度的场景： 类型 占用字节 范围 精度 float 4 ±1.5e-45 到 ±3.4e38 7 位有效数字 double 8 ±5.0e-324 到 ±1.7e308 15-16 位有效数字 decimal 16 ±1.0e-28 到 ±7.9e28 28-29 位有效数字 注意： float 需要在数字后加 f（如 3.14f）。 decimal 需要加 m（如 3.14m），适合金融计算等高精度场景。 示例代码： float temperature = 36.6f; double pi = 3.14159265359; decimal balance = 12345.6789m; 2.3 布尔类型\rbool：占用 1 字节，值只能是 true 或 false。 用于逻辑判断。 示例代码： bool isStudent = true; bool hasLicense = false; 2.4 字符类型\rchar：占用 2 字节，存储单个 Unicode 字符（用单引号 '' 表示）。 示例代码： char grade = 'A'; char symbol = '\\u0041'; // Unicode 表示 'A' 2.5 结构体 (Struct)\r结构体是用户定义的值类型，包含多个字段。例如，System.DateTime 是一个结构体。 示例代码： struct Point { public int X; public int Y; } Point p = new Point { X = 10, Y = 20 }; 3. 引用类型 (Reference Types)\r引用类型变量存储的是数据的内存地址，数据本身存储在堆内存中。常见的引用类型包括： 3.1 字符串 (String)\rstring：表示不可变的 Unicode 字符序列。 使用双引号 \"\" 定义。 示例代码： string name = \"Alice\"; string greeting = $\"Hello, {name}!\"; // 字符串插值 3.2 数组 (Array)\r数组是固定大小的元素集合，元素类型必须一致。 示例代码： int[] numbers = new int[3] { 1, 2, 3 }; string[] names = { \"Alice\", \"Bob\", \"Charlie\" }; 3.3 类 (Class)\r类是用户定义的引用类型，可以包含字段、属性、方法等。 示例代码： class Person { public string Name { get; set; } public int Age { get; set; } } Person person = new Person { Name = \"Bob\", Age = 30 }; 3.4 对象 (Object)\robject 是所有类型的基类，任何类型都可以转换为 object。 使用时需注意装箱和拆箱（见下文）。 示例代码： object obj = 42; // 装箱 int number = (int)obj; // 拆箱 4. 值类型与引用类型的区别\r特性 值类型 引用类型 存储位置 栈内存 堆内存（引用在栈中） 赋值行为 复制整个值 复制引用（指向同一对象） 默认值 0 或相应类型的默认值 null 示例 int, double, struct string, class, array 示例代码（值类型与引用类型的赋值行为）： int a = 10; int b = a; b = 20; // a 仍然是 10 Console.WriteLine(a); // 输出 10 string[] arr1 = { \"A\", \"B\" }; string[] arr2 = arr1; arr2[0] = \"C\"; // arr1[0] 也变为 \"C\" Console.WriteLine(arr1[0]); // 输出 C 5. 类型转换\rC# 中类型转换分为以下几种： 5.1 隐式转换\r低精度类型到高精度类型的自动转换，无需显式声明。 示例代码： int i = 100; double d = i; // 隐式转换 5.2 显式转换\r高精度类型到低精度类型需要强制转换，可能丢失数据。 示例代码： double d = 123.45; int i = (int)d; // 显式转换，i = 123 5.3 使用 Convert 类\rSystem.Convert 类提供多种类型转换方法。 示例代码： string str = \"123\"; int num = Convert.ToInt32(str); 5.4 使用 Parse 和 TryParse\rParse：将字符串转换为指定类型，若失败抛出异常。 TryParse：尝试转换，若失败返回 false，不抛异常。 示例代码： string str = \"123\"; int result; bool success = int.TryParse(str, out result); // success = true, result = 123 6. 装箱与拆箱 (Boxing and Unboxing)\r装箱：将值类型转换为 object 或接口类型，存储到堆内存。 拆箱：从 object 类型转换回值类型。 示例代码： int i = 42; object obj = i; // 装箱 int j = (int)obj; // 拆箱 注意：装箱和拆箱会影响性能，尽量避免在性能敏感的代码中使用。 7. 可空类型 (Nullable Types)\r值类型默认不能为 null，但可通过可空类型（如 int?）支持 null 值。 示例代码： int? nullableInt = null; if (nullableInt.HasValue) { Console.WriteLine(nullableInt.Value); } else { Console.WriteLine(\"Value is null\"); } 可空值类型简写： int? 等价于 Nullable\u003cint\u003e。 8. 动态类型 (Dynamic Type)\rdynamic 类型允许在运行时确定类型，绕过编译时类型检查。适用于与动态语言交互或未知类型的场景。 示例代码： dynamic value = 42; value = \"Now a string\"; // 动态类型允许更改类型 Console.WriteLine(value); 注意：使用 dynamic 会降低代码可读性和性能，建议谨慎使用。 9. 字面量 (Literals)\r字面量是直接在代码中书写的常量值，用于初始化变量或表示特定值。C# 支持多种类型的字面量，并允许使用前缀或后缀来指定数据类型或进制。 9.1 常见字面量类型\r整数字面量： 十进制：123 十六进制：0x7B（以 0x 开头） 二进制：0b01111011（以 0b 开头，C# 7.0+ 支持） 后缀：L（long）、UL（ulong）、U（uint）。 浮点字面量： 普通浮点：3.14 科学计数法：3.14e2（表示 3.14 × 10² = 314） 后缀：f（float）、d（double）、m（decimal）。 字符字面量：'A' 或 '\\u0041'（Unicode 字符）。 字符串字面量： 普通字符串：\"Hello\" 逐字字符串：@\"C:\\Path\"（忽略转义字符）。 插值字符串：$\"Value: {x}\"（C# 6.0+）。 布尔字面量：true、false。 空字面量：null（仅限引用类型或可空值类型）。 示例代码： int dec = 123; // 十进制 int hex = 0x7B; // 十六进制","date":"2024-08-07","objectID":"/csharp/basic/c6a99510-88ae-4d53-9fbb-a175cc2b0a07/:0:0","tags":["C#"],"title":"C#数据类型","uri":"/csharp/basic/c6a99510-88ae-4d53-9fbb-a175cc2b0a07/"},{"categories":["博客"],"content":"使用hugo new命令创建Markdown文件时，通常需要手动输入标题、日期等信息。为了简化这个过程，可以使用一个预设模板来自动生成Markdown文件的内容。 首先，你要有go环境，并安装github.com/google/uuid包来生成唯一的slug。 在目录中创建一个名为new_md.go的Go语言脚本，内容如下： package main import ( \"fmt\" \"os\" \"path/filepath\" \"strings\" \"time\" \"github.com/google/uuid\" ) const template = `--- title: \"%s\" date: %s slug: \"%s\" draft: true author: name: hobby link: https://github.com/haochan1996 email: espholychan@outllook.com avatar: https://avatars.githubusercontent.com/u/190246046?v=4 description: keywords: license: comment: false weight: 0 tags: - draft categories: - draft hiddenFromHomePage: false hiddenFromSearch: false hiddenFromRelated: false hiddenFromFeed: false summary: resources: - name: featured-image src: featured-image.jpg - name: featured-image-preview src: featured-image-preview.jpg toc: true math: false lightgallery: false password: message: repost: enable: true url: --- ## 标题二 正文内容... ` func main() { if len(os.Args) != 2 { fmt.Println(\"用法: go run py_new_md.go \u003c文件路径/文件名.md\u003e\") fmt.Println(\"请确保输入的路径存在且有效，可以使用相对或绝对路径。\") os.Exit(1) } filePath := os.Args[1] title := strings.TrimSuffix(filepath.Base(filePath), filepath.Ext(filePath)) dateStr := time.Now().Format(\"2006-01-02T15:04:05-0700\") slug := uuid.New().String() content := fmt.Sprintf(template, title, dateStr, slug) dir := filepath.Dir(filePath) // 检查目录是否存在，不存在则报错并退出 if _, err := os.Stat(dir); os.IsNotExist(err) { fmt.Printf(\"目录不存在: %s\\n\", dir) os.Exit(1) } if err := os.WriteFile(filePath, []byte(content), 0644); err != nil { fmt.Printf(\"写入文件失败: %v\\n\", err) os.Exit(1) } fmt.Printf(\"已生成: %s\\n\", filePath) } 当你运行这个脚本时，它会自动生成一个Markdown文件，包含预设的标题、日期、slug等信息。你只需要提供文件路径和文件名即可。你也可以根据实际的需求 修改模板内容。或者可以编译成可执行文件，方便使用。 // 使用方法： // go run new_md.go \u003c文件路径/文件名.md\u003e // 例如： go run new_md.go content/posts/创建预设模板内容的Markdown文件.md go run new_md.go content/csharp/wpf/布局控件.md ","date":"2025-08-05","objectID":"/posts/db9584e3-f61a-4ce4-9173-9f9a0369aee1/:0:0","tags":["博客"],"title":"创建预设模板内容的Markdown文件","uri":"/posts/db9584e3-f61a-4ce4-9173-9f9a0369aee1/"},{"categories":null,"content":"网易云音乐歌单\r","date":"2025-08-04","objectID":"/music/8dd06b96-a944-4275-ab38-4afcb8b10160/:0:0","tags":null,"title":"","uri":"/music/8dd06b96-a944-4275-ab38-4afcb8b10160/"},{"categories":["WPF"],"content":"WPF概述\rWindows Presentation Foundation 桌面指南（WPF），这是一个独立于分辨率的 UI 框架，它使用基于矢量的呈现引擎，旨在利用现代图形硬件。 WPF 提供了一组全面的应用程序开发功能，其中包括可扩展应用程序标记语言（XAML）、控件、数据绑定、布局、2D 和 3D 图形、动画、样式、模板、文档、媒体、文本和版式。 WPF 是 .NET 的一部分，因此可以生成包含 .NET API 其他元素的应用程序。 WPF 有两个实现： .NET 版本（本指南）： .NET Framework 4 版本： 尽管.Net是一种跨平台技术，但是WPF仅能在Windows上运行。 什么是XAML？\rXAML 是基于 XML 的标记语言，以声明方式实现应用程序的外观。 通常使用它来定义窗口、对话框、页面和用户控件，并用控件、形状和图形填充它们。 以下示例使用 XAML 实现包含单个按钮的窗口的外观： \u003cWindow xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" Title=\"Window with button\" Width=\"250\" Height=\"100\"\u003e \u003c!-- Add button to window --\u003e \u003cButton Name=\"button\"\u003eClick Me!\u003c/Button\u003e \u003c/Window\u003e 具体而言，此 XAML 使用 Window 和 Button 元素定义窗口和按钮。 每个元素都配置了属性，例如 Window 元素的 Title 属性来指定窗口的标题栏文本。 在运行时，WPF 将标记中定义的元素和属性转换为 WPF 类的实例。 例如，Window 元素转换为 Window 类的实例，该类 Title 属性是 Title 特性的值。 下图显示了上一示例中 XAML 定义的用户界面（UI）： WPF的项目结构\r创建WPF应用程序。 App.xaml 与 App.xaml.cs 入口点：定义应用程序启动逻辑，通过StartupUri指定初始窗口（如StartupUri=“MainWindow.xaml”）。 全局资源：在\u003cApplication.Resources\u003e中定义样式、数据模板等资源，供整个应用复用。 生命周期事件：在App.xaml.cs中重写OnStartup()初始化服务，OnExit()执行清理逻辑，DispatcherUnhandledException捕获全局异常。 MainWindow.xaml 与 MainWindow.xaml.cs 主窗口UI：XAML文件定义布局和控件（如按钮、文本框）。 事件处理：代码文件（xaml.cs）实现交互逻辑（如按钮点击事件）。 App.xaml\rApp.xaml 是 WPF（Windows Presentation Foundation）应用程序的核心文件，承担着应用程序入口点、全局资源配置中心和生命周期事件处理器等关键角色。其核心作用可归纳为以下五类： 应用程序入口与启动控制\r启动窗口定义：通过StartupUri属性指定初始窗口（如 StartupUri=\"MainWindow.xaml\"），简化启动流程。 自定义启动逻辑：删除StartupUri后，可在App.xaml.cs中重写OnStartup 方法，实现动态初始化（如窗口预配置、参数解析、依赖注入容器初始化等操作）： protected override void OnStartup(StartupEventArgs e) { base.OnStartup(e); // 示例：解析启动参数 if (e.Args.Contains(\"debug\")) DebugMode.Enable(); // 动态创建主窗口 var mainWindow = new MainWindow(); mainWindow.Title = \"Custom Title\"; mainWindow.Show(); } 全局资源集中管理\r统一样式与模板：在\u003cApplication.Resources\u003e中定义应用级资源（样式、画笔、数据模板等），确保UI一致性： \u003cApplication.Resources\u003e \u003cStyle TargetType=\"Button\"\u003e \u003cSetter Property=\"Foreground\" Value=\"Red\"/\u003e \u003cSetter Property=\"FontSize\" Value=\"14\"/\u003e \u003c/Style\u003e \u003cResourceDictionary\u003e \u003cResourceDictionary.MergedDictionaries\u003e \u003cResourceDictionary Source=\"Styles/Icons.xaml\"/\u003e \u003c/ResourceDictionary.MergedDictionaries\u003e \u003c/ResourceDictionary\u003e \u003c/Application.Resources\u003e 多语言支持：通过合并不同语言的资源字典（如 en-us.xaml, zh-cn.xaml），实现动态切换界面语言。 应用程序生命周期管理\r关键事件处理： OnStartup：初始化全局状态（如数据库连接、配置加载）。 OnExit：执行清理任务（如保存用户数据、释放资源）。 OnSessionEnding：拦截系统关机/注销事件，提示未保存数据： protected override void OnSessionEnding(SessionEndingCancelEventArgs e) { if (HasUnsavedData) { e.Cancel = true; MessageBox.Show(\"数据未保存！\"); } } 未处理异常捕获：订阅 DispatcherUnhandledException 事件，防止崩溃并记录错误。 统一 UI 行为与线程管理\r全局样式生效范围：在App.xaml中定义的隐式样式（无x:Key）自动应用于所有匹配控件，无需显式引用。 UI 线程安全：通过Application.Current.Dispatcher.Invoke确保跨线程操作 UI 的安全性（但OnStartup中无需调用，因已在主线程）。 高级配置与扩展性\r关闭模式控制：ShutdownMode属性决定应用退出时机： OnLastWindowClose（默认）：所有窗口关闭后退出。 OnMainWindowClose：主窗口关闭即退出。 OnExplicitShutdown：需手动调用 Application.Current.Shutdown()。 依赖注入集成：在OnStartup中初始化容器（如 Unity、Autofac），注册全局服务： public static IUnityContainer Container; protected override void OnStartup(StartupEventArgs e) { Container = new UnityContainer(); Container.RegisterType\u003cIDataService, DataService\u003e(); base.OnStartup(e); } Application的生命周期\rWPF（Windows Presentation Foundation）应用程序的生命周期由 Application 类管理，涵盖从启动到关闭的全过程，开发者可通过重写方法或订阅事件介入关键节点。以下是核心阶段及关键行为的解析： 启动阶段（Startup）\r触发时机：应用程序入口点（Main 方法）调用 Application.Run() 后，主窗口显示前。 核心方法：OnStartup(StartupEventArgs e)： 用于初始化全局资源（如数据库连接、配置加载）、解析命令行参数（e.Args），或动态创建启动窗口（替代 StartupUri）。 protected override void OnStartup(StartupEventArgs e) { base.OnStartup(e); MainWindow = new CustomWindow(); // 动态创建主窗口 MainWindow.Show(); } 启动画面（Splash Screen）：通过添加图像文件并设置生成操作为 SplashScreen，实现启动瞬间显示初始界面。 原生SplashScreen实现，适用于静态图片场景，性能最优，由系统级 API 支持。 实现步骤： 添加图片资源 在项目中添加图片（支持 PNG、JPEG、BMP 等格式）。 属性设置：右键图片 → 生成操作 选 SplashScreen（VS 自动生成代码）。 代码控制显示逻辑（可选高级配置） protected override void OnStartup(StartupEventArgs e) { // 创建 SplashScreen 实例（图片路径需匹配资源名） var splash = new SplashScreen(\"SplashImage.png\"); // 非自动关闭 + 置顶显示 splash.Show(false, true); // 设置超时关闭（防止主窗口卡死导致 Splash 滞留） var timer = new Timer(_ =\u003e { Dispatcher.Invoke(() =\u003e splash.Close(TimeSpan","date":"2025-08-02","objectID":"/csharp/wpf/892c051/:0:0","tags":["WPF","C#"],"title":"WPF入门","uri":"/csharp/wpf/892c051/"},{"categories":["C#基础"],"content":"1.操作符\r1.1 概述\r操作符是用于执行特定操作的符号，例如算术、比较、逻辑等。根据操作数的数量，操作符可以分为： 一元操作符：作用于一个操作数，如 -x（取反）。 二元操作符：作用于两个操作数，如 x + y。 三元操作符：作用于三个操作数，如条件操作符 condition ? true_value : false_value。 2.1 算术操作符\r算术操作符用于执行基本的数学计算，适用于数值类型（如 int、double 等）。 操作符 功能 示例 注意事项 + 加法/字符串拼接 int c = 3 + 5; string s = \"a\" + \"b\"; 字符串拼接产生新对象 - 减法 double d = 5.0 - 2.0; // 3.0 不支持ulong取负 * 乘法 float f = 2.5f * 2; // 5.0 整数乘法溢出时截断高位 / 除法 int i = 7 / 2; // 3 double k = 7.0 / 2; // 3.5 整数除法舍去小数 % 取余 int r = 10 % 3; // 1 余数符号与被除数相同 ++/-- 自增/自减 int x = 1; x++; // 2 前缀先运算后返回值，后缀反之 示例代码： int a = 10; int b = 5; int sum = a + b; // 15 int difference = a - b; // 5 int product = a * b; // 50 int quotient = a / b; // 2 int remainder = a % b; // 0 a++; // a 现在是 11 b--; // b 现在是 4 注意： 自增和自减操作符有前置（++x）和后置（x++）之分。前置先执行操作再返回值，后置先返回值再执行操作。 1.3 赋值操作符\r赋值操作符用于将值赋给变量，常见的包括简单赋值和复合赋值。 操作符 描述 示例 = 简单赋值 x = y += 加法赋值 x += y -= 减法赋值 x -= y *= 乘法赋值 x *= y /= 除法赋值 x /= y %= 取模赋值 x %= y 示例代码： int x = 10; x += 5; // x = x + 5, x 现在是 15 x -= 3; // x = x - 3, x 现在是 12 x *= 2; // x = x * 2, x 现在是 24 x /= 4; // x = x / 4, x 现在是 6 x %= 3; // x = x % 3, x 现在是 0 说明： 复合赋值操作符简化了代码，特别是在需要对变量进行多次修改时。 1.4 比较操作符\r比较操作符用于比较两个值，返回布尔值（true 或 false），常用于条件判断。 操作符 功能 示例 比较规则 ==/!= 相等/不等 \"abc\" == \"abc\"; // true 字符串比较内容，引用类型比较地址（除string） \u003e/\u003c 大于/小于 5 \u003e 3; // true 字符比较Unicode码值 \u003e=/\u003c= 大于等于/小于等于 4.5 \u003c= 4.5; // true 浮点数比较需考虑精度误差 示例代码： int a = 10; int b = 20; bool isEqual = (a == b); // false bool isNotEqual = (a != b); // true bool isGreater = (a \u003e b); // false bool isLess = (a \u003c b); // true 注意： 比较操作符常与控制流程语句（如 if）结合使用。 1.5 逻辑操作符\r逻辑操作符用于组合布尔表达式，常见于复杂条件判断。 操作符 名称 描述 \u0026\u0026 逻辑与 x \u0026\u0026 y ` ` ! 逻辑非 !x 示例代码： bool x = true; bool y = false; bool andResult = x \u0026\u0026 y; // false bool orResult = x || y; // true bool notResult = !x; // false 说明： 逻辑操作符具有短路求值特性：\u0026\u0026 在左侧为 false 时不计算右侧，|| 在左侧为 true 时不计算右侧。 1.6 位操作符\r位操作符用于操作整数的二进制位，适用于低级编程和性能优化。 操作符 功能 示例 \u0026 按位与 6 \u0026 3; // 2 (0b110 \u0026 0b011 = 0b010) ` ` 按位或 ^ 按位异或 6 ^ 3; // 5 (0b110 ^ 0b011 = 0b101) ~ 按位取反 ~6; // -7 (补码表示) \u003c\u003c/\u003e\u003e 左移/右移 4 \u003c\u003c 1; // 8 -4 \u003e\u003e 1; // -2 示例代码： int a = 5; // 二进制 0101 int b = 3; // 二进制 0011 int and = a \u0026 b; // 0001 -\u003e 1 int or = a | b; // 0111 -\u003e 7 int xor = a ^ b; // 0110 -\u003e 6 int notA = ~a; // 1010 (4位) -\u003e -6 (补码) int leftShift = a \u003c\u003c 1; // 1010 -\u003e 10 int rightShift = a \u003e\u003e 1; // 0010 -\u003e 2 注意： 位操作符在处理二进制数据、标志位等场景中非常有用。 1.7 其他操作符\rC#还包括一些特殊操作符，增强了代码的表达能力。 条件操作符（三元操作符）： 语法：condition ? true_expression : false_expression 示例： int age = 20; string status = (age \u003e= 18) ? \"Adult\" : \"Minor\"; // \"Adult\" 空合并操作符： 语法：x ?? y，若 x 为 null 则返回 y。 示例： string name = null; string displayName = name ?? \"Unknown\"; // \"Unknown\" 成员访问操作符：. 用于访问对象的成员。 示例： string length = \"hello\".Length; // 5 索引操作符：[] 用于访问数组或集合中的元素。 示例： int[] numbers = {1, 2, 3}; int first = numbers[0]; // 1 1.9 特殊操作符\rC# 还提供了一些其他特殊用途的操作符。 操作符 描述 示例 is 检查对象是否为特定类型 if (obj is string) as 执行引用转换，如果失败则返回 null string s = obj as string; new 创建新对象或调用构造函数 MyClass obj = new MyClass(); sizeof 获取类型在内存中的大小（以字节为单位） sizeof(int) typeof 获取指定类型的 System.Type 对象 Type t = typeof(string); 1.10 操作符优先级和结合性\r当一个表达式中包含多个操作符时，优先级决定了操作符的执行顺序。结合性则用于处理优先级相同的操作符，决定是从左到右还是从右到左进行计算。 优先级： 乘法 (*) 和除法 (/) 的优先级高于加法 (+) 和减法 (-)。 赋值操作符的优先级通常最低。 你可以使用括号 () 来强制改变运算顺序。 示例： int result = 5 + 3 * 2; // 结果为 11，因为先计算 3 * 2 int resultWithParentheses = (5 + 3) * 2; // 结果为 16，因为先计算括号中的 5 + 3 结合性： 大多数二元操作符（如 +, -, *, /）是左结合的，即从左到右计算。 赋值操作符（如 =) 和三元操作符 ?: 是右结合的，即从右到左计算。 2. 控制流程\r控制流程是决定程序执行顺序的关键。它允许你根据不同的条件执行不同的代码块，或者重复执行某段代码，是编写任何复杂程序的基石。C#主要有三大类控制流程语句：条件语句、循环语句和跳转语句。 2.1 条件语句 (Conditional Statements)\r条件语句用于根据某个布尔表达式的结果来决定执行哪个代码块。 if-else 语句\r这是最基本的条件语句，用于在条件为 true 或 false 时执行不同的代码。 int age = 20; if (age \u003e= 18) { Console.WriteLine(\"你已成年。\"); } else { Console.WriteLine(\"你未成年。\"); } 你可以使用 else if 来处理多个条件： int score = 85; if (score \u003e= 90) { Console.WriteLine(\"优秀\"); } else if (score \u003e= 80) { Console.WriteLine(\"良好\"); } else if (score \u003e= 60) { Console.WriteLine(\"及格\"); } else { Console.WriteLine(\"不及格\"); } switch 语句\r当你有多个针对同一变量的等值比较时，switch 语句比多个 if-else if 语句更简洁、更易读。 string day = \"Monday\"; switch (day) { case \"Mond","date":"2024-08-07","objectID":"/csharp/basic/7749b4b1-4b36-42d1-bd6c-14d264055cdb/:0:0","tags":["C#"],"title":"C#操作符和控制流程","uri":"/csharp/basic/7749b4b1-4b36-42d1-bd6c-14d264055cdb/"},{"categories":["C#基础"],"content":"1. C# 简介\rC# 是一种简单、现代、通用、面向对象的编程语言，由微软开发，旨在运行于 .NET 框架之上。它支持跨平台开发，适用于 Windows、macOS 和 Linux。C# 的设计目标包括类型安全、垃圾回收和丰富的类库，适合初学者快速上手。 历史与发展：C# 1.0 于 2002 年发布，最新版本为 C# 13（2024 年 11 月发布），与 .NET 9（2025 年 8 月 5 日发布）兼容。版本历史见 https://learn.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-version-history。 关键特性：自动垃圾回收、面向对象编程支持（封装、继承、多态）、强大的标准库、异步编程支持等。 2. 开发环境设置\r学习 C# 的第一步是设置开发环境。以下是详细步骤： 下载 .NET SDK：.NET SDK 是 C# 开发的核心组件。最新版本为 .NET 9.0.8（2025-08-05，标准支持）和 .NET 8.0.19（2025-08-05，长期支持）。下载地址：https://dotnet.microsoft.com/zh-cn/download。安装后，您可以通过命令行运行 dotnet --version 验证。 选择 IDE： Visual Studio Code：轻量级跨平台编辑器，适合初学者。下载地址：https://code.visualstudio.com/Download。安装 C# Dev Kit 扩展：https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csdevkit。 Visual Studio：功能强大的 IDE，适合 Windows 和 macOS 用户。下载地址：https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=Community\u0026rel=17。 在线编译器：如果不希望安装本地环境，可以使用在线工具，如菜鸟教程提供的编译器：https://www.runoob.com/try/showcs.php?filename=HelloWorld，适合初学者快速测试代码。 3. 基本语法\rC# 的基本语法包括变量声明、数据类型、运算符和控制结构。以下是详细内容： 3.1 Hello World 程序\r这是 C# 的入门程序，展示如何输出文本： using System; class Program { static void Main() { Console.WriteLine(\"Hello, World!\"); } } using System; 引入系统命名空间。 Main 是程序的入口点。 Console.WriteLine 用于输出文本到控制台。 从 Microsoft Learn 的交互式教程中，扩展学习包括字符串操作，如变量声明和插值： string aFriend = \"Bill\"; Console.WriteLine(aFriend); // 输出 Bill aFriend = \"Maira\"; Console.WriteLine($\"Hello {aFriend}\"); // 输出 Hello Maira 字符串方法如 Trim、Replace、ToUpper 等也非常实用，详见 https://learn.microsoft.com/zh-cn/dotnet/csharp/tour-of-csharp/tutorials/hello-world。 3.2 数据类型和变量\rC# 支持多种数据类型，初学者需掌握以下常见类型： 整型：int（32 位整数，如 int a = 18;），范围见 int.MaxValue 和 int.MinValue。 浮点型：double（双精度浮点数，如 double b = 4.5;），适合科学计算；decimal（高精度，如 decimal c = 1.0M;），用于金融计算。 字符串：string（如 string name = \"Alice\";），支持插值和方法如 Length、Contains。 数学运算示例： int a = 18; int b = 6; int c = a + b; // c = 24 Console.WriteLine(c); 注意溢出问题，如 int.MaxValue + 3 会导致负数结果，详见 https://learn.microsoft.com/zh-cn/dotnet/csharp/tour-of-csharp/tutorials/numbers。 3.3 运算符\rC# 支持算术运算符（+, -, *, /, %）、比较运算符（==, !=, \u003e, \u003c）和逻辑运算符（\u0026\u0026, ||, !）。运算顺序遵循数学规则，可用括号调整优先级。 示例： int d = a + b * c; // 先乘后加 int e = (a + b) % c; // 取余 3.4 控制结构\r控制结构包括条件判断和循环： if 语句： if (age \u003e= 18) { Console.WriteLine(\"成年人\"); } else { Console.WriteLine(\"未成年人\"); } switch 语句：用于多分支选择，示例见上文。 循环：for 循环示例： for (int i = 0; i \u003c 5; i++) { Console.WriteLine(i); // 输出 0 到 4 } 4. 面向对象编程\rC# 是面向对象的，支持封装、继承和多态。以下是详细介绍： 4.1 类和对象\r类是对象的蓝图，对象是类的实例。示例： public class Person { public string Name { get; set; } public int Age { get; set; } public void SayHello() { Console.WriteLine($\"你好，我叫 {Name}，今年 {Age} 岁。\"); } } 创建对象： Person person = new Person { Name = \"Alice\", Age = 30 }; person.SayHello(); // 输出：你好，我叫 Alice，今年 30 岁。 4.2 继承\r继承允许子类复用父类的属性和方法。示例： public class Student : Person { public string StudentId { get; set; } } 从 Microsoft Learn 的银行系统示例中，InterestEarningAccount 和 LineOfCreditAccount 继承自 BankAccount，利率分别为 2% 和 7%，详见 https://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/tutorials/oop。 4.3 多态\r多态通过 virtual 和 override 实现方法重写。示例： public class Animal { public virtual void MakeSound() { Console.WriteLine(\"动物叫\"); } } public class Dog : Animal { public override void MakeSound() { Console.WriteLine(\"汪汪\"); } } 4.4 封装\r通过访问修饰符（如 public、private）控制成员访问，保护内部实现。 5. 高级主题\r初学者可逐步学习以下高级主题： 异常处理：使用 try-catch 捕获异常，例如： try { int result = 10 / 0; } catch (DivideByZeroException e) { Console.WriteLine(\"除数不能为零：\" + e.Message); } 文件 I/O：读写文件，使用 System.IO 命名空间。 LINQ：语言集成查询，用于数据操作，示例见官方文档。 异步编程：使用 async 和 await 处理异步任务，适合网络操作。 6. 进一步学习资源\r以下是推荐的学习资源： 官方文档：https://learn.microsoft.com/zh-cn/dotnet/csharp/，提供交互式教程和参考资料。 在线教程：https://www.runoob.com/csharp/csharp-tutorial.html，适合初学者，包含在线编译器。 书籍：推荐《C# 7.0 核心技术指南》和《Head First C#》，深入学习高级概念。 社区与动态：关注 C# 技术大会（如 2025 年会议，主题为智能创新）和 GitHub 仓库（如 https://github.com/dotnet/csharplang），了解最新动态。 https://learn.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-version-history。 ","date":"2024-08-05","objectID":"/csharp/basic/d14b1543-d65d-40cb-a7c4-f3bed1e0dfc6/:0:0","tags":["C#"],"title":"C#概述","uri":"/csharp/basic/d14b1543-d65d-40cb-a7c4-f3bed1e0dfc6/"},{"categories":["博客"],"content":"1. 引言：智能电网时代下IEC 61850的崛起\r电力系统作为现代社会运行的基石，其稳定、高效运行至关重要。随着电力需求的增长和可再生能源的并网，传统电力系统面临着前所未有的挑战。变电站作为电力传输和分配的关键枢纽，其自动化水平直接影响着电网的整体性能。在这种背景下，国际电工委员会（IEC）制定的IEC 61850协议应运而生，成为推动变电站乃至整个智能电网数字化的核心标准。 1.1 传统变电站通信的局限性与标准化需求\r在20世纪90年代，随着变电站自动化技术的快速发展，不同制造商的设备采用了各自专有的通信协议，这导致了系统集成上的巨大困难和高昂的维护成本。传统的变电站自动化系统严重依赖复杂的硬接线逻辑，例如通过铜线连接的继电器和控制设备，这不仅增加了安装的复杂性和成本，也使得系统扩展和改造变得异常困难。此外，传统的通信方法，如设备轮流访问通信介质的方式，会导致不可接受的通信延迟，这对于需要毫秒级响应的保护应用而言是致命的缺陷。这种通信协议的碎片化和对物理接线的过度依赖，严重阻碍了变电站自动化系统的互操作性、可扩展性和可靠性。为了克服这些固有的局限性，电力行业迫切需要一个统一的、开放的通信标准，以实现不同制造商设备之间的无缝协作，降低系统集成难度，并提升整体运行效率和可靠性。这种对标准化和互操作性的强烈需求，直接催生了IEC 61850协议的诞生，旨在为变电站内的各种智能电子设备（IED）搭建一个通用的“语言平台”，从而根本性地解决传统系统面临的挑战。 1.2 IEC 61850标准的起源、发展历程与国际认可\rIEC 61850是国际电工委员会（IEC）专门为变电站自动化系统设计的通信标准。其起源可追溯到20世纪90年代，旨在解决当时变电站自动化领域普遍存在的不同制造商设备通信协议不统一、系统集成复杂、维护成本高昂等问题。经过多年的不懈努力和技术迭代，IEC 61850标准逐步完善。1999年，IEC发布了该标准的第一版。此后，随着电力技术和应用经验的不断积累，标准持续进行修订和更新，以适应新的需求和技术发展，确保其先进性和适用性。 进入21世纪，IEC 61850标准在全球范围内获得了广泛的推广和应用。许多国家和地区已经将其确立为变电站自动化系统建设的首选标准，极大地推动了全球电力行业的智能化发展。例如，ABB等行业领先企业在IEC 61850的制定过程中做出了重大贡献，这进一步加速了其在全球范围内的认可和采纳。该标准迅速获得了业界的认可，并越来越多地应用于低压、中压和高压的电力应用场景中。这种跨电压等级的广泛应用，充分体现了IEC 61850的普适性和强大的适应性，使其成为智能电网转型中不可或缺的基石。 1.3 IEC 61850的核心理念：互操作性、可扩展性与面向对象方法\rIEC 61850协议的核心在于其对互操作性、可扩展性和可靠性的深刻理解与实现。它超越了简单的通信协议范畴，为变电站内的智能电子设备（IED）提供了一套标准化的解决方案，使得不同制造商生产的设备能够相互理解和协作，从而显著提升了系统的互操作性、可扩展性和整体可靠性。 该标准通过引入变电站配置语言（SCL）进行一致的命名和对象建模，明确定义了设备和变电站级别的数据交换方式。这种方法使得IEC 61850成为一个厂商中立的协议，因为它在协议层级之外，进一步界定了智能电子设备（IED）的操作互通性。这意味着，无论设备来自哪个制造商，只要符合IEC 61850标准，就能在统一的框架下进行通信和数据交换。 其根本性的变革在于采用了面向对象的设计思想来对IED模型数据进行存取。这种面向对象的方法，将电力系统中的物理设备和功能抽象为标准化的对象，并赋予它们预定义、具有上下文意义的名称。通过这种方式，IEC 61850确保了数据在整个系统中的语义一致性，即数据在编译和传输过程中不会丢失其上下文意义。例如，一个断路器的状态信息，无论由哪个IED报告，都能被其他符合标准的设备以相同的方式理解。这种对对象和数据类型进行标准化以及采用正式电子描述的方法，从根本上避免了设计和配置过程中可能出现的错误。这种从“数据传输”到“具有语义的信息交换”的范式转变，是实现真正互操作性和简化系统工程的关键所在。 2. IEC 61850协议的核心架构与数据模型\rIEC 61850协议的精髓在于其分层通信架构和创新的面向对象数据模型，这两者共同构成了数字变电站高效、可靠运行的基础。 2.1 数字变电站的分层通信架构：站控层、间隔层与过程层\r数字变电站的架构根据IEC 61850标准定义为清晰的三层：过程层（Process Level）、间隔层（Bay Level）和站控层（Station Level） 。每一层都承担特定的功能，并且各层应用之间紧密配合，共同实现数字变电站的整体功能。这种分层设计不仅提供了一个清晰、结构化的系统设计方法，还允许根据数据的实时性、重要性和聚合需求来优化通信流，从而提升了系统的模块化、可维护性和故障诊断效率。 图1: 数字变电站的分层通信架构 graph TD A[过程层] --\u003e|GOOSE/SV协议| B[间隔层] B --\u003e|MMS协议| C[站控层] C --\u003e|调度指令| B B --\u003e|GOOSE控制命令| A subgraph 站控层网络 C --\u003e D[监控主机] C --\u003e E[远动装置] C --\u003e F[工程师站] D --\u003e|MMS报告| F E --\u003e|调度通信| G[控制中心] end subgraph 过程层网络 A --\u003e H[合并单元MU] A --\u003e I[智能终端] H --\u003e|SV采样值| B I --\u003e|GOOSE状态| B end\rgraph TD A[过程层] --\u003e|GOOSE/SV协议| B[间隔层] B --\u003e|MMS协议| C[站控层] C --\u003e|调度指令| B B --\u003e|GOOSE控制命令| A subgraph 站控层网络 C --\u003e D[监控主机] C --\u003e E[远动装置] C --\u003e F[工程师站] D --\u003e|MMS报告| F E --\u003e|调度通信| G[控制中心] end subgraph 过程层网络 A --\u003e H[合并单元MU] A --\u003e I[智能终端] H --\u003e|SV采样值| B I --\u003e|GOOSE状态| B end2.1.1 站控层总线与功能\r站控层是数字变电站的最高层，主要负责整个变电站的监控、管理和与外部系统的通信。这一层通常包括站控计算机、以太网交换机和用于广域通信的网关。站控总线的设计允许多个客户端设备进行数据交换，提供了超越传统SCADA（监控与数据采集）系统的额外通信功能。这意味着站控层不仅能够进行集中式的监督控制，还支持设备间的对等通信，以及通过网关实现变电站与外部控制中心或相邻变电站之间的广域通信。 站控层的设备通常包括变电站人机界面（HMI）、用于IED访问或本地集中和归档电力系统数据的工程工作站、SCADA网关以及连接到远程HMI的代理服务器或控制器。在这一层，IEC 61850的制造商信息规范（MMS）协议发挥着关键作用，它促进了智能电子设备（IED）与SCADA或RTU等高级实体之间的数据通信。MMS协议主要侧重于非时间关键型数据交换，例如配置数据、报告信息、文件传输以及一般的监控数据，这些数据通常允许秒级或数百毫秒级的响应时间，而非严格的毫秒级实时性。站控层对“超越传统SCADA”功能的强调以及对等通信的支持，表明其设计理念已超越了传统的集中式数据采集模式，转向了更具分布式智能和高级应用能力的监督控制层面，从而赋予了系统更大的灵活性和局部决策能力。 2.1.2 间隔层设备与通信\r间隔层位于站控层之下，是变电站自动化系统中执行保护、控制和测量功能的关键区域。该层主要由各种智能电子设备（IED）组成，如保护继电器、测控单元等。间隔层通信对速度和可靠性有着极高的要求，尤其是在保护和联锁应用中。 为了满足这些严苛的实时性要求，IEC 61850协议在间隔层广泛应用了通用面向对象变电站事件（GOOSE）协议，以实现继电器与自动化设备之间的高速互锁。GOOSE通信的引入，在许多情况下能够消除传统的实线式I/O连接，显著简化了布线并提高了可靠性。此外，为了确保通信的持续可用性，IEC 61850还整合了并行冗余协议（PRP）等先进的网络冗余机制，为以太网上的保护继电器提供了紧密衔接的网络备援。PRP通过双通道通信传输，即使网络中存在单点故障，也能保证GOOSE信号的可靠传输。间隔层对PRP和GOOSE协议的强调，突显了电力系统对故障容错和实时决策的极高要求。这些内置于协议层面的冗余和高速通信机制，直接提升了电网的稳定性和故障隔离速度，相较于传统方法实现了显著的性能飞跃。 2.1.3 过程层总线与数字化互感器\r过程层是数字变电站的最底层，也是最接近一次电力设备（如电源变压器、仪用互感器和开关设备）的层面。它是主要电力设备与辅助（保护和控制）设备之间的接口。在数字变电站中，所有模拟和二进制数据都会在靠近源头的位置进行数字化，然后通过光纤电缆使用**IEC 61850-9-2协议（采样值SV协议）**发送到IED。 这一层的关键组成部分包括电子式电流/电压互感器（ECT/EPT）和合并单元（Merging Unit）。合并单元负责将传统仪用互感器的模拟输出转换为标准化的以太网数据，从而实现IEC 61850通信。采样值（SV）协议是过程层通信的核心，它能够在变压器、传感器（如电流互感器CT、电压互感器PT）和一次电力系统设备之间快速交换电压、电流和状态数据。通过在过程层实现信号的数字化和光纤传输，","date":"0001-01-01","objectID":"/posts/9f9a0369aee1-f61a-4ce4-9173-9f9a0369aee1/:0:0","tags":["博客","IEC61850"],"title":"IEC 61850的全面解析","uri":"/posts/9f9a0369aee1-f61a-4ce4-9173-9f9a0369aee1/"}]