[{"categories":["Rust基础入门"],"content":"变量\r在 Rust 中，变量默认是不可变的（immutable）。这意味着一旦你给变量赋了值，就不能再改变它。这种设计是 Rust 保证内存安全和并发安全的核心思想之一。 不可变变量（Immutable Variables）\r当你声明一个变量时，如果不做任何特殊处理，它就是不可变的。 fn main() { let x = 5; println!(\"The value of x is: {}\", x); // 下面这行代码会导致编译错误，因为 x 是不可变的 // x = 6; } 编译器会报错，提示你不能对一个不可变的变量二次赋值。 可变变量（Mutable Variables）\r如果你需要一个可以改变值的变量，需要在声明时使用 mut 关键字，使其变为可变（mutable）。 fn main() { let mut x = 5; println!(\"The value of x is: {}\", x); // 现在可以修改 x 的值了 x = 6; println!(\"The new value of x is: {}\", x); } 使用 mut 关键字的好处是，它能清晰地向代码的读者表明，这个变量的值在未来的某个时刻是可能被改变的。 常量（Constants）\r除了不可变变量，Rust 还有 常量（constants）。常量和不可变变量有些相似，但有几个关键区别： 关键字: 声明常量需要使用 const 关键字，而不是 let。 可变性: 常量总是不可变的，你不能给它们加上 mut。 命名规范: 常量名通常使用全大写字母，并用下划线分隔单词，例如 MAX_POINTS。 表达式限制: 常量只能被设置为常量表达式的结果，而不能是函数调用的结果或任何在运行时计算的值。 const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3; fn main() { println!(\"Three hours in seconds is: {}\", THREE_HOURS_IN_SECONDS); } 变量遮蔽（Shadowing）\rRust 允许你用一个同名的新变量来“遮蔽”（shadow）旧的变量。当新的变量被声明后，旧的变量就无法再访问了。 这和可变变量（mut）的区别在于： mut: 修改的是同一个变量的值。 Shadowing: 创建了一个新的、同名的变量，它完全覆盖了旧的变量。 遮蔽的好处是，你可以改变变量的类型，而这是 mut 无法做到的。 fn main() { let x = 5; // 遮蔽 x let x = x + 1; { // 在内部作用域中再次遮蔽 x let x = x * 2; println!(\"The value of x in the inner scope is: {}\", x); // 输出 12 } println!(\"The value of x is: {}\", x); // 输出 6 } 在这里，内部作用域的 x 遮蔽了外部的 x，但当内部作用域结束时，外部的 x 依然是有效且未被改变的。 数据类型\r在 Rust 中，每个变量都有一个特定的数据类型。Rust 是一种静态类型语言，这意味着它在编译时就必须知道所有变量的类型。编译器通常能够根据你赋值的方式推断出类型，但有时你可能需要明确地标注类型。 基本数据类型 (Primitive Data Types)\rRust 的基本数据类型可以分为两大类：标量 (Scalar) 和 复合 (Compound)。 标量类型 (Scalar Types)\r标量类型代表一个单一的值。 整数 (Integers) 整数类型用于存储没有小数部分的数字。Rust 提供了多种有符号（i）和无符号（u）的整数类型，其名称表示其位数。 有符号整数：i8, i16, i32, i64, i128 无符号整数：u8, u16, u32, u64, u128 isize 和 usize：这两种类型的大小取决于你的计算机架构。在 64 位系统上是 64 位，在 32 位系统上是 32 位。它们主要用于索引集合或进行内存地址运算。 默认情况下，Rust 编译器会推断为 i32，这是最常见的类型。 let x = 42; // 编译器推断为 i32 let y: u64 = 10000; // 显式类型标注 浮点数 (Floating-Point Numbers) 浮点数用于存储带小数点的数字。Rust 有两种主要的浮点数类型： f32：单精度浮点数 f64：双精度浮点数 (默认) let pi = 3.14; // 编译器推断为 f64 let z: f32 = 2.718; 布尔值 (Booleans) 布尔类型只有两个可能的值：true 和 false。它的大小为 1 个字节。 let is_rust_fun = true; let is_raining: bool = false; 字符 (Characters) char 类型是 Rust 最基础的字母类型。它以 Unicode 标量值表示，可以存储比 ASCII 更丰富的字符，包括中文、日文、表情符号等。char 类型的大小为 4 个字节。 let heart_eye = '😻'; let a_letter = 'a'; 复合类型 (Compound Types)\r复合类型可以将多个值组合成一个类型。 元组 (Tuples) 元组可以将多个不同类型的值打包成一个复合类型。元组的长度是固定的，一旦声明就不能改变。 let tup: (i32, f64, char) = (500, 6.4, 'Z'); let (x, y, z) = tup; // 解构元组 println!(\"The value of y is: {}\", y); // 也可以通过索引访问元组元素 let five_hundred = tup.0; 数组 (Arrays) 数组用于存储一组相同类型的值。数组的长度是固定的。与元组不同，数组中的每个元素必须是相同的类型。 let a = [1, 2, 3, 4, 5]; let months = [\"Jan\", \"Feb\", \"Mar\"]; let first = a[0]; // 你也可以用 `[类型; 长度]` 的形式声明 let b: [i32; 5] = [1, 2, 3, 4, 5]; // 或者创建一个包含相同值的数组 let c = [3; 5]; // 等价于 [3, 3, 3, 3, 3] 访问数组元素时，如果索引超出范围，Rust 会在运行时报错（panic），从而避免了许多 C/C++ 等语言中的缓冲区溢出问题。 类型转换 (Type Casting)\r在 Rust 中，类型转换不是隐式进行的，你需要显式地进行转换。 let integer = 10; let float = 5.5; // 这行代码会报错，因为 i32 和 f64 不能直接相加 // let sum = integer + float; let sum = integer as f64 + float; // 将 integer 转换为 f64 println!(\"Sum is: {}\", sum); 通过这种方式，Rust 保证了类型安全，让你能清楚地知道代码中发生的类型转换。 函数\r函数是 Rust 程序的基本构建块。你已经见过了最重要的函数 main，它是很多程序的入口点。你也见过了 fn 关键字，它用来声明新函数。 函数定义\rRust 代码中的函数定义以 fn 开始，后跟函数名和一对圆括号。大括号告诉编译器哪里是函数体的开始和结尾。 fn main() { println!(\"Hello, world!\"); another_function(); } fn another_function() { println!(\"Another function.\"); } 在 Rust 中，函数名使用下划线命名法（snake case），即所有字母都是小写并使用下划线分隔单词。 注意在 main 函数中调用了 another_function。我们能够调用它是因为它在源码中的某个地方被定义过了。Rust 不关心你在哪里定义函数，只要你在某个地方定义了它们。 函数参数\r我们可以定义为拥有 参数（parameters） 的函数，参数是特殊变量，是函数签名的一部分。当函数拥有参数（形参）时，可以为这些参数提供具体的值（实参）。 fn main() { print_labeled_measurement(5, 'h'); } fn print_labeled_measurement(value: i32, unit_label: char) { println!(\"The measurement is: {value}{unit_label}\"); } 在函数签名中，必须 声明每个参数的类型。这是 Rust 设计中一个经过深思熟虑的决定：要求在函数定义中提供类型注解，意味着编译器不需要你在代码的其他地方注明类型来推断你的意图。 当定义多个参数时，使用逗号分隔参数声明，像这样： fn greet(name: \u0026str, age: i32) { println!(\"Hello, {}! You are {} years old.\", name, age); } fn main() { greet(\"Alice\", 30); } 语句和表达式\r函数体由一系列的语句和一个可选的结尾表达式构成。到目前为止，我们提到","date":"2025-08-14","objectID":"/rust/basic/e0e61349-11a8-4cef-bb97-8bd12d84e769/:0:0","tags":["Rust"],"title":"Rust通用编程概念","uri":"/rust/basic/e0e61349-11a8-4cef-bb97-8bd12d84e769/"},{"categories":["博客"],"content":"1. 引言：智能电网时代下IEC 61850的崛起\r电力系统作为现代社会运行的基石，其稳定、高效运行至关重要。随着电力需求的增长和可再生能源的并网，传统电力系统面临着前所未有的挑战。变电站作为电力传输和分配的关键枢纽，其自动化水平直接影响着电网的整体性能。在这种背景下，国际电工委员会（IEC）制定的IEC 61850协议应运而生，成为推动变电站乃至整个智能电网数字化的核心标准。 1.1 传统变电站通信的局限性与标准化需求\r在20世纪90年代，随着变电站自动化技术的快速发展，不同制造商的设备采用了各自专有的通信协议，这导致了系统集成上的巨大困难和高昂的维护成本。传统的变电站自动化系统严重依赖复杂的硬接线逻辑，例如通过铜线连接的继电器和控制设备，这不仅增加了安装的复杂性和成本，也使得系统扩展和改造变得异常困难。此外，传统的通信方法，如设备轮流访问通信介质的方式，会导致不可接受的通信延迟，这对于需要毫秒级响应的保护应用而言是致命的缺陷。这种通信协议的碎片化和对物理接线的过度依赖，严重阻碍了变电站自动化系统的互操作性、可扩展性和可靠性。为了克服这些固有的局限性，电力行业迫切需要一个统一的、开放的通信标准，以实现不同制造商设备之间的无缝协作，降低系统集成难度，并提升整体运行效率和可靠性。这种对标准化和互操作性的强烈需求，直接催生了IEC 61850协议的诞生，旨在为变电站内的各种智能电子设备（IED）搭建一个通用的“语言平台”，从而根本性地解决传统系统面临的挑战。 1.2 IEC 61850标准的起源、发展历程与国际认可\rIEC 61850是国际电工委员会（IEC）专门为变电站自动化系统设计的通信标准。其起源可追溯到20世纪90年代，旨在解决当时变电站自动化领域普遍存在的不同制造商设备通信协议不统一、系统集成复杂、维护成本高昂等问题。经过多年的不懈努力和技术迭代，IEC 61850标准逐步完善。1999年，IEC发布了该标准的第一版。此后，随着电力技术和应用经验的不断积累，标准持续进行修订和更新，以适应新的需求和技术发展，确保其先进性和适用性。 进入21世纪，IEC 61850标准在全球范围内获得了广泛的推广和应用。许多国家和地区已经将其确立为变电站自动化系统建设的首选标准，极大地推动了全球电力行业的智能化发展。例如，ABB等行业领先企业在IEC 61850的制定过程中做出了重大贡献，这进一步加速了其在全球范围内的认可和采纳。该标准迅速获得了业界的认可，并越来越多地应用于低压、中压和高压的电力应用场景中。这种跨电压等级的广泛应用，充分体现了IEC 61850的普适性和强大的适应性，使其成为智能电网转型中不可或缺的基石。 1.3 IEC 61850的核心理念：互操作性、可扩展性与面向对象方法\rIEC 61850协议的核心在于其对互操作性、可扩展性和可靠性的深刻理解与实现。它超越了简单的通信协议范畴，为变电站内的智能电子设备（IED）提供了一套标准化的解决方案，使得不同制造商生产的设备能够相互理解和协作，从而显著提升了系统的互操作性、可扩展性和整体可靠性。 该标准通过引入变电站配置语言（SCL）进行一致的命名和对象建模，明确定义了设备和变电站级别的数据交换方式。这种方法使得IEC 61850成为一个厂商中立的协议，因为它在协议层级之外，进一步界定了智能电子设备（IED）的操作互通性。这意味着，无论设备来自哪个制造商，只要符合IEC 61850标准，就能在统一的框架下进行通信和数据交换。 其根本性的变革在于采用了面向对象的设计思想来对IED模型数据进行存取。这种面向对象的方法，将电力系统中的物理设备和功能抽象为标准化的对象，并赋予它们预定义、具有上下文意义的名称。通过这种方式，IEC 61850确保了数据在整个系统中的语义一致性，即数据在编译和传输过程中不会丢失其上下文意义。例如，一个断路器的状态信息，无论由哪个IED报告，都能被其他符合标准的设备以相同的方式理解。这种对对象和数据类型进行标准化以及采用正式电子描述的方法，从根本上避免了设计和配置过程中可能出现的错误。这种从“数据传输”到“具有语义的信息交换”的范式转变，是实现真正互操作性和简化系统工程的关键所在。 2. IEC 61850协议的核心架构与数据模型\rIEC 61850协议的精髓在于其分层通信架构和创新的面向对象数据模型，这两者共同构成了数字变电站高效、可靠运行的基础。 2.1 数字变电站的分层通信架构：站控层、间隔层与过程层\r数字变电站的架构根据IEC 61850标准定义为清晰的三层：过程层（Process Level）、间隔层（Bay Level）和站控层（Station Level） 。每一层都承担特定的功能，并且各层应用之间紧密配合，共同实现数字变电站的整体功能。这种分层设计不仅提供了一个清晰、结构化的系统设计方法，还允许根据数据的实时性、重要性和聚合需求来优化通信流，从而提升了系统的模块化、可维护性和故障诊断效率。 图1: 数字变电站的分层通信架构 graph TD A[过程层] --\u003e |GOOSE/SV协议| B[间隔层] B --\u003e |MMS协议| C[站控层] C --\u003e |调度指令| B B --\u003e |GOOSE控制命令| A subgraph 站控层网络 C --\u003e D[监控主机] C --\u003e E[远动装置] C --\u003e F[工程师站] D --\u003e |MMS报告| F E --\u003e |调度通信| G[控制中心] end subgraph 过程层网络 A --\u003e H[合并单元MU] A --\u003e I[智能终端] H --\u003e |SV采样值| B I --\u003e |GOOSE状态| B end\rgraph TD A[过程层] --\u003e |GOOSE/SV协议| B[间隔层] B --\u003e |MMS协议| C[站控层] C --\u003e |调度指令| B B --\u003e |GOOSE控制命令| A subgraph 站控层网络 C --\u003e D[监控主机] C --\u003e E[远动装置] C --\u003e F[工程师站] D --\u003e |MMS报告| F E --\u003e |调度通信| G[控制中心] end subgraph 过程层网络 A --\u003e H[合并单元MU] A --\u003e I[智能终端] H --\u003e |SV采样值| B I --\u003e |GOOSE状态| B end2.1.1 站控层总线与功能\r站控层是数字变电站的最高层，主要负责整个变电站的监控、管理和与外部系统的通信。这一层通常包括站控计算机、以太网交换机和用于广域通信的网关。站控总线的设计允许多个客户端设备进行数据交换，提供了超越传统SCADA（监控与数据采集）系统的额外通信功能。这意味着站控层不仅能够进行集中式的监督控制，还支持设备间的对等通信，以及通过网关实现变电站与外部控制中心或相邻变电站之间的广域通信。 站控层的设备通常包括变电站人机界面（HMI）、用于IED访问或本地集中和归档电力系统数据的工程工作站、SCADA网关以及连接到远程HMI的代理服务器或控制器。在这一层，IEC 61850的制造商信息规范（MMS）协议发挥着关键作用，它促进了智能电子设备（IED）与SCADA或RTU等高级实体之间的数据通信。MMS协议主要侧重于非时间关键型数据交换，例如配置数据、报告信息、文件传输以及一般的监控数据，这些数据通常允许秒级或数百毫秒级的响应时间，而非严格的毫秒级实时性。站控层对“超越传统SCADA”功能的强调以及对等通信的支持，表明其设计理念已超越了传统的集中式数据采集模式，转向了更具分布式智能和高级应用能力的监督控制层面，从而赋予了系统更大的灵活性和局部决策能力。 2.1.2 间隔层设备与通信\r间隔层位于站控层之下，是变电站自动化系统中执行保护、控制和测量功能的关键区域。该层主要由各种智能电子设备（IED）组成，如保护继电器、测控单元等。间隔层通信对速度和可靠性有着极高的要求，尤其是在保护和联锁应用中。 为了满足这些严苛的实时性要求，IEC 61850协议在间隔层广泛应用了通用面向对象变电站事件（GOOSE）协议，以实现继电器与自动化设备之间的高速互锁。GOOSE通信的引入，在许多情况下能够消除传统的实线式I/O连接，显著简化了布线并提高了可靠性。此外，为了确保通信的持续可用性，IEC 61850还整合了并行冗余协议（PRP）等先进的网络冗余机制，为以太网上的保护继电器提供了紧密衔接的网络备援。PRP通过双通道通信传输，即使网络中存在单点故障，也能保证GOOSE信号的可靠传输。间隔层对PRP和GOOSE协议的强调，突显了电力系统对故障容错和实时决策的极高要求。这些内置于协议层面的冗余和高速通信机制，直接提升了电网的稳定性和故障隔离速度，相较于传统方法实现了显著的性能飞跃。 2.1.3 过程层总线与数字化互感器\r过程层是数字变电站的最底层，也是最接近一次电力设备（如电源变压器、仪用互感器和开关设备）的层面。它是主要电力设备与辅助（保护和控制）设备之间的接口。在数字变电站中，所有模拟和二进制数据都会在靠近源头的位置进行数字化，然后通过光纤电缆使用**IEC 61850-9-2协议（采样值SV协议）**发送到IED。 这一层的关键组成部分包括电子式电流/电压互感器（ECT/EPT）和合并单元（Merging Unit）。合并单元负责将传统仪用互感器的模拟输出转换为标准化的以太网数据，从而实现IEC 61850通信。采样值（SV）协议是过程层通信的核心，它能够在变压器、传感器（如电流互感器CT、电压互感器PT）和一次电力系统设备之间快速交换电压、电流和状态数据。通过在过","date":"2025-08-11","objectID":"/posts/9f9a0369aee1-f61a-4ce4-9173-9f9a0369aee1/:0:0","tags":["电力协议"],"title":"IEC 61850协议详解","uri":"/posts/9f9a0369aee1-f61a-4ce4-9173-9f9a0369aee1/"},{"categories":["博客"],"content":"使用hugo new命令创建Markdown文件时，通常需要手动输入标题、日期等信息。为了简化这个过程，可以使用一个预设模板来自动生成Markdown文件的内容。 首先，你要有go环境，并安装github.com/google/uuid包来生成唯一的slug。 在目录中创建一个名为new_md.go的Go语言脚本，内容如下： package main import ( \"fmt\" \"os\" \"path/filepath\" \"strings\" \"time\" \"github.com/google/uuid\" ) const template = `--- title: \"%s\" date: %s slug: \"%s\" draft: true author: name: hobby link: https://github.com/haochan1996 email: espholychan@outllook.com avatar: https://avatars.githubusercontent.com/u/190246046?v=4 description: keywords: license: comment: false weight: 0 tags: - draft categories: - draft hiddenFromHomePage: false hiddenFromSearch: false hiddenFromRelated: false hiddenFromFeed: false summary: resources: - name: featured-image src: featured-image.jpg - name: featured-image-preview src: featured-image-preview.jpg toc: true math: false lightgallery: false password: message: repost: enable: true url: --- ## 标题二 正文内容... ` func main() { if len(os.Args) != 2 { fmt.Println(\"用法: go run py_new_md.go \u003c文件路径/文件名.md\u003e\") fmt.Println(\"请确保输入的路径存在且有效，可以使用相对或绝对路径。\") os.Exit(1) } filePath := os.Args[1] title := strings.TrimSuffix(filepath.Base(filePath), filepath.Ext(filePath)) dateStr := time.Now().Format(\"2006-01-02T15:04:05-0700\") slug := uuid.New().String() content := fmt.Sprintf(template, title, dateStr, slug) dir := filepath.Dir(filePath) // 检查目录是否存在，不存在则报错并退出 if _, err := os.Stat(dir); os.IsNotExist(err) { fmt.Printf(\"目录不存在: %s\\n\", dir) os.Exit(1) } if err := os.WriteFile(filePath, []byte(content), 0644); err != nil { fmt.Printf(\"写入文件失败: %v\\n\", err) os.Exit(1) } fmt.Printf(\"已生成: %s\\n\", filePath) } 当你运行这个脚本时，它会自动生成一个Markdown文件，包含预设的标题、日期、slug等信息。你只需要提供文件路径和文件名即可。你也可以根据实际的需求 修改模板内容。或者可以编译成可执行文件，方便使用。 // 使用方法： // go run new_md.go \u003c文件路径/文件名.md\u003e // 例如： go run new_md.go content/posts/创建预设模板内容的Markdown文件.md go run new_md.go content/csharp/wpf/布局控件.md ","date":"2025-08-05","objectID":"/posts/db9584e3-f61a-4ce4-9173-9f9a0369aee1/:0:0","tags":["博客"],"title":"创建预设模板内容的Markdown文件","uri":"/posts/db9584e3-f61a-4ce4-9173-9f9a0369aee1/"},{"categories":["WPF"],"content":"WPF 布局控件（继承自 Panel 类, 除了Border）通过测量（Measure）和排列（Arrange）两个阶段自动计算子元素的位置与尺寸，支持动态适应窗口大小变化。布局控件通过 Children 属性容纳子元素（如按钮、文本框等），支持嵌套组合实现复杂界面。 控件 布局方式 Grid 网格，根据自定义行和列来设置控件的布局 StackPanel 堆叠，包含的元素在垂直或水平方向排列 WrapPanel 流式布局，自动换行/列 DockPanel 边缘停靠+剩余填充 Canvas 画布，内部元素以像素为单位绝对坐标定位 UniformGrid 均分网格，相当于Grid的简化版，每个单元格的大小相同 Border 装饰的控件，用于绘制边框及背景，在Border中只能有一个子控件 Panel基类\rPanel 是 Windows Presentation Foundation（WPF）中提供布局支持的所有元素的基类。 Panel派生元素用于在可扩展应用程序标记语言（XAML）和代码中定位和排列元素。 WPF 包含一套全面的派生面板实现，可实现许多复杂布局。 这些派生类公开了启用大多数标准用户界面（UI）方案的属性和方法。 无法找到满足其需求的子排列行为的开发人员可以通过重写 ArrangeOverride 和 MeasureOverride 方法创建新的布局。 所有Panel元素都支持由FrameworkElement定义的基本大小调整和定位属性，包括Height、Width、HorizontalAlignment、VerticalAlignment和MarginLayoutTransform。 有关定位属性 FrameworkElement的其他信息，请参阅 对齐、边距和填充概述。 Panel 公开了在理解和使用布局时极为重要的附加属性。 该Background属性用于用一个Brush填充派生面板元素的边界之间的区域。 Children 表示由其 Panel 构成的元素的子集合。 InternalChildren 表示集合的内容 Children 以及数据绑定生成的成员。 两者都由父级UIElementCollection托管的子元素组成Panel。 面板还公开了一个 Panel.ZIndex 附加属性，该属性可用于在派生 Panel中实现分层顺序。 具有较高Children值的面板Panel.ZIndex集合的成员显示在值较低的Panel.ZIndex集合前面。 这对于面板特别有用，例如CanvasGrid，允许子元素共享相同的坐标空间。 Panel 还定义了 OnRender 方法，该方法可用于替代默认 Panel呈现行为。 Panel提供了GetZIndex和SetZIndex方法成员，分别表示获取某个元素的Zindex顺序和设置某个元素的ZIndex顺序。 什么是ZIndex?这是Panel提供的一个附加属性。假如一个单行单列的Grid布局控件中有两个Button,正常情况下，这两个Button都会以撑满Grid的方式星现在Grid中，那么，到底哪一个Button在上面，哪一个Button在下面呢?就看这两个Button的Panel.ZIndex附加属性的值，值越大越在上面，而值较小的那个Button将被上面的Button遮盖，从而在视觉上，用户只能看到一个Button。 Grid(网格布局)\r通过行（RowDefinitions）和列（ColumnDefinitions）定义表格结构，支持单元格合并与动态尺寸调整。 关键属性： Grid.Row / Grid.Column：指定子元素位置。 RowSpan / ColumnSpan：跨行/列。 ShowGridLines: 是否显示网格线 Grid的列宽与行高可采用固定、自动、按比例三种方式定义。 固定长度：值为一个确定的数字 自动长度：值为Auto，实际作用就是取实际控件所需的最小值 比例长度： *表示占用剩余的全部宽度；两行都是*，将平分剩余宽度; 一个2*，一个*，则前者占剩余全部宽度的2/3，后者占1/3; 示例： \u003cGrid\u003e \u003cGrid.RowDefinitions\u003e \u003c!--设置4行--\u003e \u003cRowDefinition Height=\"40\"\u003e\u003c/RowDefinition\u003e \u003cRowDefinition Height=\"Auto\"\u003e\u003c/RowDefinition\u003e \u003cRowDefinition Height=\"2*\"\u003e\u003c/RowDefinition\u003e \u003cRowDefinition Height=\"*\"\u003e\u003c/RowDefinition\u003e \u003c/Grid.RowDefinitions\u003e \u003cButton Grid.Row=\"0\" Content=\"Button 1\"\u003e\u003c/Button\u003e \u003cButton Grid.Row=\"1\" Content=\"Button 2\"\u003e\u003c/Button\u003e \u003cButton Grid.Row=\"2\" Content=\"Button 3\"\u003e\u003c/Button\u003e \u003cButton Grid.Row=\"3\" Content=\"Button 4\"\u003e\u003c/Button\u003e \u003c/Grid\u003e 效果： StackPanel(堆叠布局)\r子元素按单一方向（Orientation=\"Vertical\" 或 Horizontal\"）线性排列，不自动换行。默认方向是垂直排列（Orientation=\"Vertical\"），子元素从上到下堆叠。如果要设置水平排列，设置 Orientation=\"Horizontal\"，子元素从左到右排列。垂直布局时，子元素宽度默认拉伸至 StackPanel 的宽度，高度由内容决定（或显式设置）。水平布局时，子元素高度拉伸至 StackPanel 高度，宽度由内容决定。 StackPanel关键属性如下： 属性 说明 示例值 Orientation 排列方向：Vertical（默认）或 Horizontal Orientation=\"Horizontal\" Margin 容器外间距，控制与父容器的距离 Margin=\"10\" Padding 容器内边距，控制子元素与容器边界的距离 Padding=\"5\" Background 背景色（未设置时不响应鼠标事件） Background=\"LightGray\" HorizontalAlignment 容器在父容器中的水平对齐方式（Left/Center/Right/Stretch） HorizontalAlignment=\"Center\" VerticalAlignment 容器在父容器中的垂直对齐方式（Top/Center/Bottom/Stretch） VerticalAlignment=\"Top\" 布局嵌套\rStackPanel 可嵌套其他容器（如 Grid、嵌套的 StackPanel）实现复杂结构 \u003c!-- 垂直布局嵌套水平布局 --\u003e \u003cStackPanel Orientation=\"Vertical\"\u003e \u003cTextBlock Text=\"用户登录\"/\u003e \u003cStackPanel Orientation=\"Horizontal\"\u003e \u003c!-- 水平布局 --\u003e \u003cTextBlock Text=\"用户名：\" VerticalAlignment=\"Center\"/\u003e \u003cTextBox Width=\"200\"/\u003e \u003c/StackPanel\u003e \u003cButton Content=\"提交\"/\u003e \u003c/StackPanel\u003e 滚动支持\r通过 ScrollViewer 包裹 StackPanel 解决内容溢出问题 \u003cScrollViewer Height=\"150\"\u003e \u003cStackPanel\u003e \u003cButton Content=\"Item 1\" Height=\"40\"/\u003e \u003c!-- 更多子元素 --\u003e \u003c/StackPanel\u003e \u003c/ScrollViewer\u003e 动态操作子元素\r在代码中动态添加/删除子元素 // 添加按钮 private void AddButton_Click(object sender, RoutedEventArgs e) { Button newBtn = new Button { Content = \"New Button\" }; stackPanel.Children.Add(newBtn); } // 删除最后一个按钮 private void RemoveButton_Click(object sender, RoutedEventArgs e) { if (stackPanel.Children.Count \u003e 0) stackPanel.Children.RemoveAt(stackPanel.Children.Count - 1); } WrapPanel(流式布局)\rWrapPanel与StackPanel类似的功能, 相对于WrapPanel , 具有在有限的容器范围内, 可以自动换行, 或者换列处理。 具体则取决于WrapPanel的排列方式 (Orientation)： Orientation=\"Horizontal\"时各控件从左至右排列，当面板长度不够时，子控件就会自动换行，继续按照从左至右的顺序排列 Orientation=\"Vertical\"时各控件从上至下排列，当面板高度不够时，子控件就会自动换列，继续按照从上至下的顺序排列 示例： \u003cWrapPanel Orientation=\"Horizontal\"\u003e \u003cButton Content=\"Button 150\" Wid","date":"2025-08-05","objectID":"/csharp/wpf/64d18599-4cf7-40aa-b995-9cc111f50bd3/:0:0","tags":["WPF","C#"],"title":"WPF布局控件","uri":"/csharp/wpf/64d18599-4cf7-40aa-b995-9cc111f50bd3/"},{"categories":["C#基础"],"content":"1. 什么是数据类型？\r数据类型定义了变量可以存储的数据种类、占用内存的大小以及可以对变量执行的操作。C# 中的数据类型主要分为两类： 值类型 (Value Types)：直接存储数据，如整数、浮点数、布尔值等。 引用类型 (Reference Types)：存储数据的引用（内存地址），如字符串、数组、类等。 2. 值类型 (Value Types)\r值类型变量直接在栈内存中存储实际数据。以下是常见的内置值类型： 2.1 整数类型\r整数类型用于存储没有小数部分的数字。C# 提供多种整数类型，区别在于大小和是否支持负数： 类型 占用字节 范围 描述 byte 1 0 到 255 无符号 8 位整数 sbyte 1 -128 到 127 有符号 8 位整数 short 2 -32,768 到 32,767 有符号 16 位整数 ushort 2 0 到 65,535 无符号 16 位整数 int 4 -2,147,483,648 到 2,147,483,647 有符号 32 位整数 uint 4 0 到 4,294,967,295 无符号 32 位整数 long 8 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 有符号 64 位整数 ulong 8 0 到 18,446,744,073,709,551,615 无符号 64 位整数 示例代码： int age = 25; long bigNumber = 1234567890123L; // 使用 L 表示 long 类型 byte smallNumber = 255; 2.2 浮点类型\r浮点类型用于存储带小数部分的数字，适用于需要高精度的场景： 类型 占用字节 范围 精度 float 4 ±1.5e-45 到 ±3.4e38 7 位有效数字 double 8 ±5.0e-324 到 ±1.7e308 15-16 位有效数字 decimal 16 ±1.0e-28 到 ±7.9e28 28-29 位有效数字 注意： float 需要在数字后加 f（如 3.14f）。 decimal 需要加 m（如 3.14m），适合金融计算等高精度场景。 示例代码： float temperature = 36.6f; double pi = 3.14159265359; decimal balance = 12345.6789m; 2.3 布尔类型\rbool：占用 1 字节，值只能是 true 或 false。 用于逻辑判断。 示例代码： bool isStudent = true; bool hasLicense = false; 2.4 字符类型\rchar：占用 2 字节，存储单个 Unicode 字符（用单引号 '' 表示）。 示例代码： char grade = 'A'; char symbol = '\\u0041'; // Unicode 表示 'A' 2.5 结构体 (Struct)\r结构体是用户定义的值类型，包含多个字段。例如，System.DateTime 是一个结构体。 示例代码： struct Point { public int X; public int Y; } Point p = new Point { X = 10, Y = 20 }; 3. 引用类型 (Reference Types)\r引用类型变量存储的是数据的内存地址，数据本身存储在堆内存中。常见的引用类型包括： 3.1 字符串 (String)\rstring：表示不可变的 Unicode 字符序列。 使用双引号 \"\" 定义。 示例代码： string name = \"Alice\"; string greeting = $\"Hello, {name}!\"; // 字符串插值 3.2 数组 (Array)\r数组是固定大小的元素集合，元素类型必须一致。 示例代码： int[] numbers = new int[3] { 1, 2, 3 }; string[] names = { \"Alice\", \"Bob\", \"Charlie\" }; 3.3 类 (Class)\r类是用户定义的引用类型，可以包含字段、属性、方法等。 示例代码： class Person { public string Name { get; set; } public int Age { get; set; } } Person person = new Person { Name = \"Bob\", Age = 30 }; 3.4 对象 (Object)\robject 是所有类型的基类，任何类型都可以转换为 object。 使用时需注意装箱和拆箱（见下文）。 示例代码： object obj = 42; // 装箱 int number = (int)obj; // 拆箱 4. 值类型与引用类型的区别\r特性 值类型 引用类型 存储位置 栈内存 堆内存（引用在栈中） 赋值行为 复制整个值 复制引用（指向同一对象） 默认值 0 或相应类型的默认值 null 示例 int, double, struct string, class, array 示例代码（值类型与引用类型的赋值行为）： int a = 10; int b = a; b = 20; // a 仍然是 10 Console.WriteLine(a); // 输出 10 string[] arr1 = { \"A\", \"B\" }; string[] arr2 = arr1; arr2[0] = \"C\"; // arr1[0] 也变为 \"C\" Console.WriteLine(arr1[0]); // 输出 C 5. 类型转换\rC# 中类型转换分为以下几种： 5.1 隐式转换\r低精度类型到高精度类型的自动转换，无需显式声明。 示例代码： int i = 100; double d = i; // 隐式转换 5.2 显式转换\r高精度类型到低精度类型需要强制转换，可能丢失数据。 示例代码： double d = 123.45; int i = (int)d; // 显式转换，i = 123 5.3 使用 Convert 类\rSystem.Convert 类提供多种类型转换方法。 示例代码： string str = \"123\"; int num = Convert.ToInt32(str); 5.4 使用 Parse 和 TryParse\rParse：将字符串转换为指定类型，若失败抛出异常。 TryParse：尝试转换，若失败返回 false，不抛异常。 示例代码： string str = \"123\"; int result; bool success = int.TryParse(str, out result); // success = true, result = 123 6. 装箱与拆箱 (Boxing and Unboxing)\r装箱：将值类型转换为 object 或接口类型，存储到堆内存。 拆箱：从 object 类型转换回值类型。 示例代码： int i = 42; object obj = i; // 装箱 int j = (int)obj; // 拆箱 注意：装箱和拆箱会影响性能，尽量避免在性能敏感的代码中使用。 7. 可空类型 (Nullable Types)\r值类型默认不能为 null，但可通过可空类型（如 int?）支持 null 值。 示例代码： int? nullableInt = null; if (nullableInt.HasValue) { Console.WriteLine(nullableInt.Value); } else { Console.WriteLine(\"Value is null\"); } 可空值类型简写： int? 等价于 Nullable\u003cint\u003e。 8. 动态类型 (Dynamic Type)\rdynamic 类型允许在运行时确定类型，绕过编译时类型检查。适用于与动态语言交互或未知类型的场景。 示例代码： dynamic value = 42; value = \"Now a string\"; // 动态类型允许更改类型 Console.WriteLine(value); 注意：使用 dynamic 会降低代码可读性和性能，建议谨慎使用。 9. 字面量 (Literals)\r字面量是直接在代码中书写的常量值，用于初始化变量或表示特定值。C# 支持多种类型的字面量，并允许使用前缀或后缀来指定数据类型或进制。 9.1 常见字面量类型\r整数字面量： 十进制：123 十六进制：0x7B（以 0x 开头） 二进制：0b01111011（以 0b 开头，C# 7.0+ 支持） 后缀：L（long）、UL（ulong）、U（uint）。 浮点字面量： 普通浮点：3.14 科学计数法：3.14e2（表示 3.14 × 10² = 314） 后缀：f（float）、d（double）、m（decimal）。 字符字面量：'A' 或 '\\u0041'（Unicode 字符）。 字符串字面量： 普通字符串：\"Hello\" 逐字字符串：@\"C:\\Path\"（忽略转义字符）。 插值字符串：$\"Value: {x}\"（C# 6.0+）。 布尔字面量：true、false。 空字面量：null（仅限引用类型或可空值类型）。 示例代码： int dec = 123; // 十进制 int hex = 0x7B; // 十六进制","date":"2024-08-07","objectID":"/csharp/basic/c6a99510-88ae-4d53-9fbb-a175cc2b0a07/:0:0","tags":["C#"],"title":"C#数据类型","uri":"/csharp/basic/c6a99510-88ae-4d53-9fbb-a175cc2b0a07/"},{"categories":["Rust基础入门"],"content":"深入理解Rust所有权系统，包括所有权规则、借用、生命周期等核心概念","date":"2025-08-16","objectID":"/rust/basic/38984233-be8b-4f04-bf7a-1a0f947eb699/","tags":["Rust"],"title":"Rust所有权系统","uri":"/rust/basic/38984233-be8b-4f04-bf7a-1a0f947eb699/"},{"categories":["Rust基础入门"],"content":"什么是所有权\r所有权（ownership）是 Rust 最为与众不同的特性，它让 Rust 无需垃圾回收（garbage collector）即可保障内存安全。因此，理解所有权如何工作是十分重要的。 在其他系统编程语言中，如 C 和 C++，程序员需要手动管理内存的分配和释放，这容易导致内存泄漏、悬垂指针等问题。而在带有垃圾回收的语言中，如 Java、Python，虽然不用手动管理内存，但会有运行时性能开销。 Rust 选择了第三条道路：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。如果违反了任何这些规则，程序都不能编译。在运行时，所有权系统的任何功能都不会减慢程序。 栈（Stack）与堆（Heap）\r在深入所有权之前，让我们了解一下栈和堆。这些概念对于理解所有权系统至关重要。 栈（Stack）： 存储数据的顺序是后进先出（LIFO） 所有存储在栈上的数据都必须是已知且固定的大小 访问速度快，因为数据总是在栈顶添加或移除 堆（Heap）： 用于存储编译时大小未知或大小可能变化的数据 分配内存时，内存分配器在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个指针 访问速度较慢，因为必须先访问指针，然后跟踪指针到达数据 fn main() { // 这些值存储在栈上，因为它们有已知的固定大小 let x = 5; let y = true; let z = 'a'; // 这个字符串字面值存储在程序二进制文件中，变量存储的是指向它的引用 let s1 = \"hello\"; // 这个 String 的数据存储在堆上，变量存储的是指向堆数据的指针 let s2 = String::from(\"hello\"); } 所有权规则\rRust 的所有权有三个基本规则： Rust 中的每一个值都有一个被称为其所有者（owner）的变量 值在任一时刻有且只有一个所有者 当所有者（变量）离开作用域，这个值将被丢弃 让我们通过例子来理解这些规则： 变量作用域\r作用域是一个项（item）在程序中有效的范围： fn main() { { // s 在这里无效，它尚未声明 let s = \"hello\"; // 从此处起，s 是有效的 // 使用 s println!(\"{}\", s); } // 此作用域已结束，s 不再有效 } 当变量离开作用域，Rust 为我们调用一个特殊的函数 drop，在这个函数中可以放置释放内存的代码。 String 类型\r为了演示所有权规则，我们需要一个比之前介绍的都要复杂的数据类型。之前介绍的类型都是存储在栈上的，当离开作用域时被移出栈。而现在我们要看看存储在堆上的数据。 fn main() { // 字符串字面值是不可变的 let s1 = \"hello\"; // String 类型是可变的，存储在堆上 let mut s2 = String::from(\"hello\"); s2.push_str(\", world!\"); // push_str() 在字符串后追加字面值 println!(\"{}\", s2); // 将打印 `hello, world!` } 内存与分配\r对于String类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着： 必须在运行时向内存分配器（memory allocator）请求内存 需要一个当我们处理完String时将内存返回给分配器的方法 第一部分由我们完成：当调用String::from时，它的实现请求其所需的内存。 第二部分在大部分语言中，要么有垃圾回收器，要么我们必须手动释放。Rust采取了一个不同的策略：内存在拥有它的变量离开作用域后就被自动释放。 fn main() { { let s = String::from(\"hello\"); // 从此处起，s 是有效的 // 使用 s println!(\"{}\", s); } // 此作用域已结束， // s 不再有效，内存被释放 } 变量与数据的交互方式\r移动（Move）\r在Rust中，多个变量可以采用不同的方式与同一数据进行交互： fn main() { // 对于简单的标量值，这样做没问题 let x = 5; let y = x; // x 的值被复制给 y，现在栈上有两个值都是 5 println!(\"x = {}, y = {}\", x, y); // 这样使用是可以的 } 但是对于String类型： fn main() { let s1 = String::from(\"hello\"); let s2 = s1; // s1 的值移动到了 s2 // println!(\"{}\", s1); // 这行代码会报错！s1 不再有效 println!(\"{}\", s2); // 这是可以的 } 为什么会这样？当我们将s1赋给s2，String的数据被复制了，这意味着我们从栈上拷贝了它的指针、长度和容量。我们并没有复制指针指向的堆上数据。 当变量离开作用域后，Rust自动调用drop函数并清理变量的堆内存。但是当s2和s1离开作用域，它们都会尝试释放相同的内存。这是一个叫做二次释放（double free）的错误。 为了确保内存安全，在let s2 = s1之后，Rust认为s1不再有效，因此Rust不需要在s1离开作用域后清理任何东西。这在Rust中被称为移动（move）。 克隆（Clone）\r如果我们确实需要深度复制String中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做clone的通用函数： fn main() { let s1 = String::from(\"hello\"); let s2 = s1.clone(); // 深拷贝堆上的数据 println!(\"s1 = {}, s2 = {}\", s1, s2); // 现在两个都有效 } 拷贝（Copy）\r对于像整型这样的类型，它们完全存储在栈上，所以拷贝其实际的值是快速的： fn main() { let x = 5; let y = x; println!(\"x = {}, y = {}\", x, y); // 都有效 } 这里没有调用clone，不过x依然有效且没有被移动到y中。原因是像整型这样的类型在编译时是已知大小的，会被存储在栈上，所以拷贝其实际的值是快速的。 Rust 有一个叫做Copytrait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上。如果一个类型实现了Copytrait，那么一个旧的变量在将其赋值给其他变量后仍然可用。 以下是一些 Copy 的类型： 所有整数类型，比如u32 布尔类型，bool 所有浮点数类型，比如f64 字符类型，char 元组，当且仅当其包含的类型也都实现Copy的时候。比如，(i32,i32)实现了Copy，但(i32,String)就没有 所有权与函数\r将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会移动或者复制，就像赋值语句一样： fn main() { let s = String::from(\"hello\"); // s 进入作用域 takes_ownership(s); // s 的值移动到函数里 // 所以到这里不再有效 let x = 5; // x 进入作用域 makes_copy(x); // x 应该移动函数里， // 但 i32 是 Copy 的， // 所以在后面可继续使用 x println!(\"x = {}\", x); // 这里可以使用 x // println!(\"s = {}\", s); // 这里不能使用 s，会编译错误 } // 这里，x 先移出了作用域，然后是 s。但因为 s 的值已经被移动，没什么特殊之处 fn takes_ownership(some_string: String) { // some_string 进入作用域 println!(\"{}\", some_string); } // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放 fn makes_copy(some_integer: i32) { // some_integer 进入作用域 println!(\"{}\", some_integer); } // 这里，some_integer 移出作用域。没什么特殊之处 返回值与作用域\r返回值也可以转移所有权： fn main() { let s1 = gives_ownership(); // gives_ownership 将返回值 // 移给 s1 let s2 = String::from(\"hello\"); // s2 进入作用域 let s3 = takes_and_gives_back(s2); // s2 被移动到 // takes_and_gives_back 中, // 它也将返回值移给 s3 println!(\"s1 = {}, s3 = {}\", s1, s3); // println!(\"s2 = {}\", s2); // s2 已经被移动，不能使用 } // 这里，s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走， // 所以什么也不会发生。s1 移出作用域并被丢弃 fn gives_ownership() -\u003e String { // gives_ownership 将返回值移动给 // 调用它的函数 let some_string = String::from(\"yours\"); // some_string 进","date":"2025-08-16","objectID":"/rust/basic/38984233-be8b-4f04-bf7a-1a0f947eb699/:0:0","tags":["Rust"],"title":"Rust所有权系统","uri":"/rust/basic/38984233-be8b-4f04-bf7a-1a0f947eb699/"},{"categories":["WPF"],"content":"Control类\r定义:表示用户界面(UI)元素的基类，这些元素使用 ControlTemplate 来定义其外观。 Control是许多控件的基类。比如最常见的按钮(Button)、单选(RadioButton)、复选(CheckBox)、文本框(TextBox)、 ListBox、DataGrid、日期控件等等。这些控件通常用于展示程序的数据或获取用户输入的数据，我们可以将这一类型的控件称为内容控件或数据控件，它们与前面的布局控件有一定的区别，布局控件更专注于界面，而内容控件更专注于数据(业务)。 Control类虽然可以实例化，但是在界面上是不会有任何显示的。只有那些继承了Control的子类(控件)才会在界面上显示，而且所呈现的样子各不相同，为什么会是这样呢? 因为Control类提供了一个控件模板(ControlTemplate)，而几乎所有的子类都对这个ControlTemplate进行了各自的实现，所以在呈现子类时，我们才会看到Button拥有Button的样子，TextBox拥有TextBox的样子。 \u003cControl\u003e \u003cControl.Template\u003e \u003cControlTemplate TargetType=\"Control\"\u003e \u003cBorder Width=\"200\" Height=\"200\" Background=\"Red\" CornerRadius=\"100\"\u003e \u003cTextBlock Text=\"内容控件\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\" Foreground=\"White\" FontSize=\"24\"/\u003e \u003c/Border\u003e \u003c/ControlTemplate\u003e \u003c/Control.Template\u003e \u003c/Control\u003e 效果 控件属性\r属性名称 说明 字体与文本 FontFamily 设置控件的字体系列（如 Arial、微软雅黑）。 FontSize 设置字体大小（单位：设备无关像素）。 FontStyle 设置字体样式（如 Normal、Italic）。 FontWeight 设置字体粗细（如 Normal、Bold）。 FontStretch 控制字体拉伸程度（如 Condensed、Expanded）。 颜色与背景 Foreground 设置前景色（文本/图标颜色），类型为 Brush（支持纯色、渐变等）。 Background 设置背景色（控件内部填充色），类型为 Brush。 BorderBrush 设置边框颜色，类型为 Brush。 布局与尺寸 Width / Height 显式设置控件的宽度和高度（支持 Auto 自适应）。 MinWidth / MinHeight 设置控件的最小宽度/高度（约束尺寸范围）。 MaxWidth / MaxHeight 设置控件的最大宽度/高度。 Margin 设置控件的外边距（与其他元素的距离）。 Padding 设置控件的内边距（内容与边框的距离）。 内容对齐 HorizontalContentAlignment 设置内容的水平对齐方式（Left/Center/Right）。 VerticalContentAlignment 设置内容的垂直对齐方式（Top/Center/Bottom）。 边框设置 BorderThickness 设置边框的厚度（如 \"1\" 或 \"1,2,3,4\" 分方向设置）。 交互行为 IsTabStop 控制是否可通过 Tab 键导航到该控件（默认 True）。 TabIndex 设置 Tab 键导航时的顺序（数值越小优先级越高）。 Cursor 设置鼠标悬停时的光标样式（如 Hand、Wait）。 模板与样式 Template 定义控件的视觉模板（通过 ControlTemplate 完全自定义外观）。 Style 引用样式资源，批量设置属性值（如全局按钮样式）。 其他 ToolTip 设置鼠标悬停时的提示信息（支持富文本）。 ContextMenu 设置右键上下文菜单。 Visibility 控制可见性（Visible/Collapsed/Hidden）。 Opacity 设置透明度（0.0 完全透明 ~ 1.0 不透明）。 大部分的属性都比较好理解，这里着重介绍一下Template属性。属性 Template 是，ControlTemplate指定的外观 Control。如果要更改控件的外观但保留其功能，应考虑创建新 ControlTemplate 控件，而不是创建新类。如果把人比作是一个Control(控件)，那么”着装“就是Template(模板)。在大街上，我们会看到不同着装的人来来往往。 事件处理\r事件名称 触发时机 常见用途 生命周期事件 Initialized 控件初始化完成，属性已设置但尚未布局或渲染时触发。 初始化非依赖属性或执行早期配置。 Loaded 控件完成布局、数据绑定和渲染，可用于交互时触发。 加载数据、启动动画或执行依赖布局的逻辑。 Unloaded 控件从视觉树中移除时触发。 释放资源、取消订阅事件或清理后台任务。 鼠标事件 MouseEnter 鼠标指针进入控件边界时触发。 显示悬停提示（ToolTip）或高亮控件。 MouseLeave 鼠标指针离开控件边界时触发。 隐藏提示或恢复控件默认状态。 MouseLeftButtonDown 鼠标左键在控件上按下时触发（注意：Button 等控件默认抑制此事件）。 启动拖拽操作或自定义点击逻辑（需配合 e.Handled 处理）。 MouseLeftButtonUp 鼠标左键在控件上释放时触发。 完成拖拽或确认点击操作。 MouseMove 鼠标在控件上移动时持续触发。 实时追踪鼠标位置（如绘图工具）。 MouseDoubleClick 双击控件时触发（仅限 Control 派生类）。 快速编辑操作（如列表项双击打开详情）。 键盘事件 KeyDown 控件获得焦点且键盘按键按下时触发。 捕获快捷键（如 Enter 提交表单）。 KeyUp 控件获得焦点且键盘按键释放时触发。 响应按键释放后的状态更新。 焦点事件 GotFocus 控件获得逻辑焦点时触发。 激活编辑模式或显示辅助UI。 LostFocus 控件失去逻辑焦点时触发。 验证输入数据或保存编辑内容。 拖拽事件 DragEnter 拖拽对象进入控件边界时触发（需设置 AllowDrop=\"True\"）。 检查拖拽数据类型并显示视觉反馈（如高亮边框）。 DragOver 拖拽对象在控件上移动时持续触发。 动态更新拖拽位置（如实时调整插入点）。 Drop 拖拽对象在控件上释放时触发。 处理拖拽数据（如文件导入或控件重定位）。 WPF 的 Control 事件基于路由事件模型，分为冒泡路由（从子控件向父容器传递）和隧道路由（从父容器向子控件传递，以 Preview 前缀标识，如 PreviewMouseLeftButtonDown）。实际应用中需注意： 事件抑制：部分控件（如Button）会标记e.Handled=true抑制底层事件（如MouseLeftButtonDown），此时需改用Preview事件或显式调用AddHandler。 拖拽必要条件：接收拖拽事件的控件必须设置AllowDrop=\"True\"且Background非null（建议设为 Transparent）。 性能优化：高频事件（如 MouseMove）中避免复杂逻辑，或使用去抖机制（Debounce）减少处理频率。 命令与行为：为解耦 UI 与逻辑，建议将事件处理封装为 Behavior（如拖拽行为）或绑定到 ICommand 实现 MVVM 模式。 ControlContent（内容控件）\rContentControl是WPF中用于承载任意类型内容的基类，其核心是通过Content 属性动态显示数据或UI元素。 核心特性\r内容灵活性：Content 属性类型为 object，可接受字符串、图像、其他控件（如 Button）甚至复杂数据对象。 模板化支持：通过 ContentTemplate 属性自定义内容的视觉呈现方式（如将数据对象转换为富文本布局）。 数据绑定：支持将 Content 绑定到数据源（如数据库字段、XML 节点），实现动态更新。 自定义内容模板\r将数据对象转换为复杂 UI（如员工卡片） \u003cContentControl Content=\"{Binding Employee}\"\u003e \u003cContentControl.ContentTemplate\u003e \u003cDataTemplate\u003e \u003cStackPanel\u003e \u003cImage Source=\"{Binding Avatar}\" Width=\"50\"/\u003e \u003cTextBlock Text=\"{Binding Name}\" FontWeight=\"Bold\"/\u003e \u003c/StackPanel\u003e \u003c/DataTemplate\u003e \u003c/ContentControl.ContentTemplate\u003e \u003c/ContentControl\u003e Button(按钮控件)\rButton继承自ButtonBase，是用户交互的核心控件，用于触发命令或事件。 核心属性详解\r属性 说明 示例 Content 按钮显示内容（支持任意对象） \u003cButton Content=\"提交\"/\u003e 或 \u003cButton\u003e \u003cImage Source=\"icon.png\"/\u003e \u003c/Button\u003e Command 绑定执行命令（如 SaveCommand） \u003cButt","date":"2025-08-06","objectID":"/csharp/wpf/5f4d026a-d256-4989-a4e0-7399716779bd/:0:0","tags":["WPF","C#"],"title":"WPF内容控件","uri":"/csharp/wpf/5f4d026a-d256-4989-a4e0-7399716779bd/"},{"categories":["Rust基础入门"],"content":"深入学习Rust结构体，包括定义、实例化、方法、关联函数等核心概念","date":"2025-08-19","objectID":"/rust/basic/800ae850-1128-4994-b419-72cb33047087/","tags":["Rust"],"title":"Rust结构体","uri":"/rust/basic/800ae850-1128-4994-b419-72cb33047087/"},{"categories":["Rust基础入门"],"content":"什么是结构体\r结构体（struct）是一种自定义数据类型，允许你将多个相关联的值组合在一起，形成一个有意义的组合。如果你熟悉面向对象语言，结构体就像对象的数据属性。 结构体和元组类似，都可以包含多个不同类型的值。但与元组不同的是，结构体需要为每个数据片段命名，这样就更清楚各个值的意义，也不需要依赖数据的顺序来访问结构体的值。 定义和实例化结构体\r定义结构体\r使用 struct 关键字来定义结构体，并为整个结构体提供一个名字。结构体的名字需要描述它所组合的数据的意义。接着，在大括号中，定义每一部分数据的名字和类型，我们称为字段（field）： struct User { active: bool, username: String, email: String, sign_in_count: u64, } 实例化结构体\r一旦定义了结构体，我们可以通过为每个字段指定具体值来创建这个结构体的实例： fn main() { let user1 = User { active: true, username: String::from(\"someusername123\"), email: String::from(\"someone@example.com\"), sign_in_count: 1, }; println!(\"User: {}\", user1.username); } 为了从结构体中获取某个值，我们使用点号。如果结构体的实例是可变的，我们也可以使用点号并为对应的字段赋值。注意整个实例必须是可变的；Rust 并不允许只将某个字段标记为可变。 fn main() { let mut user1 = User { active: true, username: String::from(\"someusername123\"), email: String::from(\"someone@example.com\"), sign_in_count: 1, }; user1.email = String::from(\"anotheremail@example.com\"); } 使用字段初始化简写语法\r当变量名与字段名相同时，可以使用字段初始化简写语法（field init shorthand）： fn build_user(email: String, username: String) -\u003e User { User { active: true, username, // 简写，等同于 username: username, email, // 简写，等同于 email: email, sign_in_count: 1, } } 使用结构体更新语法从其他实例创建实例\r使用结构体更新语法（struct update syntax）可以基于其他实例创建新实例： fn main() { let user1 = User { active: true, username: String::from(\"someusername123\"), email: String::from(\"someone@example.com\"), sign_in_count: 1, }; let user2 = User { active: user1.active, username: user1.username, email: String::from(\"another@example.com\"), sign_in_count: user1.sign_in_count, }; // 使用结构体更新语法，更简洁的写法 let user3 = User { email: String::from(\"another@example.com\"), ..user1 // 必须放在最后，表示剩余字段应从 user1 获取值 }; // 注意：user1 在这里不再可用，因为 username 被移动了 // println!(\"{}\", user1.username); // 这行会编译错误 } 注意，结构体更新语法就像带有 = 的赋值，因为它移动了数据。在上面的例子中，我们在创建 user3 后不能再使用 user1，因为 user1 的 username 字段中的 String 被移到 user3 中。如果我们给 user3 的 email 和 username 都赋予新的 String 值，而只使用 user1 的 active 和 sign_in_count 值，那么 user1 在创建 user3 后仍然有效。 元组结构体\rRust 还支持类似元组的结构体，称为元组结构体（tuple structs）。元组结构体有着结构体名称提供的含义，但没有具体的字段名，只有字段的类型： struct Color(i32, i32, i32); struct Point(i32, i32, i32); fn main() { let black = Color(0, 0, 0); let origin = Point(0, 0, 0); // 访问元组结构体的值 println!(\"Black color: ({}, {}, {})\", black.0, black.1, black.2); } 注意 black 和 origin 值的类型不同，因为它们是不同的元组结构体的实例。你定义的每一个结构体有其自己的类型，即使结构体中的字段有着相同的类型。 类单元结构体\r你也可以定义一个没有任何字段的结构体！它们被称为类单元结构体（unit-like structs）因为它们类似于 ()，即 unit 类型： struct AlwaysEqual; fn main() { let subject = AlwaysEqual; } 类单元结构体常常在你想要在某个类型上实现 trait 但不需要在类型中存储数据的时候发挥作用。 结构体数据的所有权\r在上面的 User 结构体的定义中，我们使用了自身拥有所有权的 String 类型而不是 \u0026str 字符串 slice 类型。这是一个有意而为之的选择，因为我们想要这个结构体拥有它所有的数据，为此只要整个结构体是有效的话其数据也是有效的。 可以使结构体存储被其他对象拥有的数据的引用，不过这么做的话需要用上生命周期（lifetimes），这是一个后面会讨论的 Rust 功能。生命周期确保结构体引用的数据有效性跟结构体本身保持一致。如果你尝试在结构体中存储一个引用而不指定生命周期将是无效的： // 这个不能编译！ struct User { active: bool, username: \u0026str, // 缺少生命周期说明符 email: \u0026str, // 缺少生命周期说明符 sign_in_count: u64, } fn main() { let user1 = User { active: true, username: \"someusername123\", email: \"someone@example.com\", sign_in_count: 1, }; } 方法语法\r方法（method）与函数类似：它们使用 fn 关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码。不过方法与函数是不同的，因为它们在结构体的上下文中被定义，并且它们第一个参数总是 self，它代表调用该方法的结构体实例。 定义方法\r让我们把前面实现的求面积的函数改写成 Rectangle 结构体上的 area 方法： #[derive(Debug)] struct Rectangle { width: u32, height: u32, } impl Rectangle { fn area(\u0026self) -\u003e u32 { self.width * self.height } } fn main() { let rect1 = Rectangle { width: 30, height: 50, }; println!( \"The area of the rectangle is {} square pixels.\", rect1.area() ); } 为了使函数定义于 Rectangle 的上下文中，我们开始了一个 impl（implementation）块。这个 impl 块中的所有内容都将与 Rectangle 类型相关联。 在 area 的签名中，我们使用 \u0026self 来替代 rectangle: \u0026Rectangle。\u0026self 实际上是 self: \u0026Self 的缩写。在一个 impl 块中，Self 类型是 impl 块的类型的别名。方法的第一个参数必须有一个名为 self 的 Self 类型的参数，所以 Rust 让你在第一个参数位置上只用 self 这个名字来缩写。 我们仍然需要在 self 前面使用 \u0026 来表示这个方法借用了 Self 实例，就像我们在 rectangle: \u0026Rectangle 中做的那样。方法可以选择获得 self 的所有权，或者像我们这里一样不可变地借用 self，或者可变地借用 self，就跟其他参数一样。 带有更多参数的方法\r让我们通过实现 Rectangle 结构体上的另一方法来练习使用方法。这次，我们让一个 Rectangle 的实例获取另一个 Rectangle 实例，如果 self 能完全包含第二个长方形则返回 true；否则返回 false： impl Rectangle { fn area(\u0026self) -\u003e u","date":"2025-08-19","objectID":"/rust/basic/800ae850-1128-4994-b419-72cb33047087/:0:0","tags":["Rust"],"title":"Rust结构体","uri":"/rust/basic/800ae850-1128-4994-b419-72cb33047087/"},{"categories":["Rust基础入门"],"content":"令狐大神学习视频链接，点击跳转播放。 Rust语言编程基础教程 Rust编程语言入门教程（Rust语言/Rust权威指南配套） Rust 程序设计语言 中文版 基础学习主要结合上面两个资料。 环境搭建\rWindows 系统​： 访问 Rust 官网，下载 rustup-init.exe。 运行安装程序，选择默认选项（按回车）。安装过程会自动配置环境变量，需重启终端生效。 依赖项​：安装过程中需勾选 ​​“Visual Studio C++ Build Tools”​​（包含MSVC编译器）。 macOS/Linux 系统​： 打开终端，执行以下命令： curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh 安装完成后重启终端，或运行 source $HOME/.cargo/env 加载环境变量。 ​依赖项​： macOS：安装 Xcode 命令行工具：xcode-select --install Ubuntu/Debian：安装编译工具链：sudo apt install build-essential Cargo 介绍\rCargo 是 Rust 官方提供的构建系统（Build System）和包管理器（Package Manager），与 Rust 编译器 rustc 深度集成，负责管理项目的全生命周期： 包管理：自动下载、编译、链接依赖库（称为 “crates”），解决版本冲突。 构建流程：编译源代码，生成可执行文件或库，支持调试与发布模式。 项目标准化：统一项目结构、测试框架、文档生成与发布流程，提升协作效率。 💡 定位类比： 类似 JavaScript 的 npm、Python 的 pip、Java 的 Maven。 Cargo核心功能详解\r项目初始化\r创建新项目： cargo new my_project # 二进制项目 cargo new my_lib --lib # 库项目 生成标准结构： my_project/ ├── Cargo.toml # 项目配置 ├── src/ │ └── main.rs # 入口文件（或 lib.rs 库项目） └── .gitignore # 默认 Git 配置 依赖管理\r在Cargo.toml 中声明依赖： [dependencies] serde = \"1.0\" # 指定版本 tokio = { version = \"1.0\", features = [\"full\"] } # 启用特性[6](@ref) Cargo 自动从crates.io（Rust 官方包仓库）下载依赖，并生成版本锁文件Cargo.lock。 构建与运行\r调试构建： cargo build # 输出到 target/debug/ cargo run # 编译后立即运行 快速检查代码确保其可以编译，但并不产生可执行文件： cargo check 发布构建（优化性能）： cargo build --release # 输出到 target/release/ 测试与文档\r运行测试： cargo test # 执行所有标记 #[test] 的测试函数 生成文档： cargo doc --open # 自动生成 HTML 文档并打开浏览器 发布与共享\r发布项目到crates.io： cargo publish # 需提前登录并配置 API Key 在 Cargo 项目中运行指定二进制文件\r若项目包含多个入口（如多个 main.rs），可通过配置实现： 配置 Cargo.toml： 在 Cargo.toml中添加多个 [[bin]]目标： [[bin]] name = \"cli\" path = \"src/cli/main.rs\" [[bin]] name = \"server\" path = \"src/server/main.rs\" 运行指定目标： cargo run --bin cli # 运行 cli 程序 cargo run --bin server # 运行 server 程序 此方法需预先定义路径，适合结构化项目 创建hello项目\rcargo new hello # 创建项目 cargo run # 编译，运行 生成的项目结构： hello/ ├── Cargo.toml # 项目配置 ├── src/ │ └── main.rs # 入口文件（或 lib.rs 库项目） └── .gitignore # 默认 Git 配置 默认的main.rs文件： fn main() { println!(\"Hello, world!\"); } main 函数（也称为主函数）很特殊：它始终是每个可执行 Rust 程序中运行的第一个代码。第一行声明一个名为 main 的函数，不带参数也没有返回值。如果有参数，那么它们的名字会放到括号内，它们将放在括号 () 内。。 cargo run运行结果： D:\\rs_learn\\hello\u003ecargo run Compiling hello v0.1.0 (D:\\rs_learn\\hello) Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.48s Running `target\\debug\\hello.exe` Hello, world! 程序会先编译生成二进制文件target\\debug\\hello.exe，然后运行。你看到 “Hello, world!” 字符串。我们将这个字符串作为参数传递给 println!，接着 println! 将字符串打印到屏幕上。 ","date":"2025-08-14","objectID":"/rust/basic/96e9d38d-4156-45d0-942f-2c7c1c25e1aa/:0:0","tags":["Rust"],"title":"rust语言以及课程介绍","uri":"/rust/basic/96e9d38d-4156-45d0-942f-2c7c1c25e1aa/"},{"categories":null,"content":"网易云音乐歌单\r","date":"2025-08-04","objectID":"/music/8dd06b96-a944-4275-ab38-4afcb8b10160/:0:0","tags":null,"title":"","uri":"/music/8dd06b96-a944-4275-ab38-4afcb8b10160/"},{"categories":["WPF"],"content":"WPF概述\rWindows Presentation Foundation 桌面指南（WPF），这是一个独立于分辨率的 UI 框架，它使用基于矢量的呈现引擎，旨在利用现代图形硬件。 WPF 提供了一组全面的应用程序开发功能，其中包括可扩展应用程序标记语言（XAML）、控件、数据绑定、布局、2D 和 3D 图形、动画、样式、模板、文档、媒体、文本和版式。 WPF 是 .NET 的一部分，因此可以生成包含 .NET API 其他元素的应用程序。 WPF 有两个实现： .NET 版本（本指南）： .NET Framework 4 版本： 尽管.Net是一种跨平台技术，但是WPF仅能在Windows上运行。 什么是XAML？\rXAML 是基于 XML 的标记语言，以声明方式实现应用程序的外观。 通常使用它来定义窗口、对话框、页面和用户控件，并用控件、形状和图形填充它们。 以下示例使用 XAML 实现包含单个按钮的窗口的外观： \u003cWindow xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" Title=\"Window with button\" Width=\"250\" Height=\"100\"\u003e \u003c!-- Add button to window --\u003e \u003cButton Name=\"button\"\u003eClick Me!\u003c/Button\u003e \u003c/Window\u003e 具体而言，此 XAML 使用 Window 和 Button 元素定义窗口和按钮。 每个元素都配置了属性，例如 Window 元素的 Title 属性来指定窗口的标题栏文本。 在运行时，WPF 将标记中定义的元素和属性转换为 WPF 类的实例。 例如，Window 元素转换为 Window 类的实例，该类 Title 属性是 Title 特性的值。 下图显示了上一示例中 XAML 定义的用户界面（UI）： WPF的项目结构\r创建WPF应用程序。 App.xaml 与 App.xaml.cs 入口点：定义应用程序启动逻辑，通过StartupUri指定初始窗口（如StartupUri=“MainWindow.xaml”）。 全局资源：在\u003cApplication.Resources\u003e中定义样式、数据模板等资源，供整个应用复用。 生命周期事件：在App.xaml.cs中重写OnStartup()初始化服务，OnExit()执行清理逻辑，DispatcherUnhandledException捕获全局异常。 MainWindow.xaml 与 MainWindow.xaml.cs 主窗口UI：XAML文件定义布局和控件（如按钮、文本框）。 事件处理：代码文件（xaml.cs）实现交互逻辑（如按钮点击事件）。 App.xaml\rApp.xaml 是 WPF（Windows Presentation Foundation）应用程序的核心文件，承担着应用程序入口点、全局资源配置中心和生命周期事件处理器等关键角色。其核心作用可归纳为以下五类： 应用程序入口与启动控制\r启动窗口定义：通过StartupUri属性指定初始窗口（如 StartupUri=\"MainWindow.xaml\"），简化启动流程。 自定义启动逻辑：删除StartupUri后，可在App.xaml.cs中重写OnStartup 方法，实现动态初始化（如窗口预配置、参数解析、依赖注入容器初始化等操作）： protected override void OnStartup(StartupEventArgs e) { base.OnStartup(e); // 示例：解析启动参数 if (e.Args.Contains(\"debug\")) DebugMode.Enable(); // 动态创建主窗口 var mainWindow = new MainWindow(); mainWindow.Title = \"Custom Title\"; mainWindow.Show(); } 全局资源集中管理\r统一样式与模板：在\u003cApplication.Resources\u003e中定义应用级资源（样式、画笔、数据模板等），确保UI一致性： \u003cApplication.Resources\u003e \u003cStyle TargetType=\"Button\"\u003e \u003cSetter Property=\"Foreground\" Value=\"Red\"/\u003e \u003cSetter Property=\"FontSize\" Value=\"14\"/\u003e \u003c/Style\u003e \u003cResourceDictionary\u003e \u003cResourceDictionary.MergedDictionaries\u003e \u003cResourceDictionary Source=\"Styles/Icons.xaml\"/\u003e \u003c/ResourceDictionary.MergedDictionaries\u003e \u003c/ResourceDictionary\u003e \u003c/Application.Resources\u003e 多语言支持：通过合并不同语言的资源字典（如 en-us.xaml, zh-cn.xaml），实现动态切换界面语言。 应用程序生命周期管理\r关键事件处理： OnStartup：初始化全局状态（如数据库连接、配置加载）。 OnExit：执行清理任务（如保存用户数据、释放资源）。 OnSessionEnding：拦截系统关机/注销事件，提示未保存数据： protected override void OnSessionEnding(SessionEndingCancelEventArgs e) { if (HasUnsavedData) { e.Cancel = true; MessageBox.Show(\"数据未保存！\"); } } 未处理异常捕获：订阅 DispatcherUnhandledException 事件，防止崩溃并记录错误。 统一 UI 行为与线程管理\r全局样式生效范围：在App.xaml中定义的隐式样式（无x:Key）自动应用于所有匹配控件，无需显式引用。 UI 线程安全：通过Application.Current.Dispatcher.Invoke确保跨线程操作 UI 的安全性（但OnStartup中无需调用，因已在主线程）。 高级配置与扩展性\r关闭模式控制：ShutdownMode属性决定应用退出时机： OnLastWindowClose（默认）：所有窗口关闭后退出。 OnMainWindowClose：主窗口关闭即退出。 OnExplicitShutdown：需手动调用 Application.Current.Shutdown()。 依赖注入集成：在OnStartup中初始化容器（如 Unity、Autofac），注册全局服务： public static IUnityContainer Container; protected override void OnStartup(StartupEventArgs e) { Container = new UnityContainer(); Container.RegisterType\u003cIDataService, DataService\u003e(); base.OnStartup(e); } Application的生命周期\rWPF（Windows Presentation Foundation）应用程序的生命周期由 Application 类管理，涵盖从启动到关闭的全过程，开发者可通过重写方法或订阅事件介入关键节点。以下是核心阶段及关键行为的解析： 启动阶段（Startup）\r触发时机：应用程序入口点（Main 方法）调用 Application.Run() 后，主窗口显示前。 核心方法：OnStartup(StartupEventArgs e)： 用于初始化全局资源（如数据库连接、配置加载）、解析命令行参数（e.Args），或动态创建启动窗口（替代 StartupUri）。 protected override void OnStartup(StartupEventArgs e) { base.OnStartup(e); MainWindow = new CustomWindow(); // 动态创建主窗口 MainWindow.Show(); } 启动画面（Splash Screen）：通过添加图像文件并设置生成操作为 SplashScreen，实现启动瞬间显示初始界面。 原生SplashScreen实现，适用于静态图片场景，性能最优，由系统级 API 支持。 实现步骤： 添加图片资源 在项目中添加图片（支持 PNG、JPEG、BMP 等格式）。 属性设置：右键图片 → 生成操作 选 SplashScreen（VS 自动生成代码）。 代码控制显示逻辑（可选高级配置） protected override void OnStartup(StartupEventArgs e) { // 创建 SplashScreen 实例（图片路径需匹配资源名） var splash = new SplashScreen(\"SplashImage.png\"); // 非自动关闭 + 置顶显示 splash.Show(false, true); // 设置超时关闭（防止主窗口卡死导致 Splash 滞留） var timer = new Timer(_ =\u003e { Dispatcher.Invoke(() =\u003e splash.Close(TimeSpan","date":"2025-08-02","objectID":"/csharp/wpf/892c051/:0:0","tags":["WPF","C#"],"title":"WPF入门","uri":"/csharp/wpf/892c051/"},{"categories":["C#基础"],"content":"1.操作符\r1.1 概述\r操作符是用于执行特定操作的符号，例如算术、比较、逻辑等。根据操作数的数量，操作符可以分为： 一元操作符：作用于一个操作数，如 -x（取反）。 二元操作符：作用于两个操作数，如 x + y。 三元操作符：作用于三个操作数，如条件操作符 condition ? true_value : false_value。 2.1 算术操作符\r算术操作符用于执行基本的数学计算，适用于数值类型（如 int、double 等）。 操作符 功能 示例 注意事项 + 加法/字符串拼接 int c = 3 + 5; string s = \"a\" + \"b\"; 字符串拼接产生新对象 - 减法 double d = 5.0 - 2.0; // 3.0 不支持ulong取负 * 乘法 float f = 2.5f * 2; // 5.0 整数乘法溢出时截断高位 / 除法 int i = 7 / 2; // 3 double k = 7.0 / 2; // 3.5 整数除法舍去小数 % 取余 int r = 10 % 3; // 1 余数符号与被除数相同 ++/-- 自增/自减 int x = 1; x++; // 2 前缀先运算后返回值，后缀反之 示例代码： int a = 10; int b = 5; int sum = a + b; // 15 int difference = a - b; // 5 int product = a * b; // 50 int quotient = a / b; // 2 int remainder = a % b; // 0 a++; // a 现在是 11 b--; // b 现在是 4 注意： 自增和自减操作符有前置（++x）和后置（x++）之分。前置先执行操作再返回值，后置先返回值再执行操作。 1.3 赋值操作符\r赋值操作符用于将值赋给变量，常见的包括简单赋值和复合赋值。 操作符 描述 示例 = 简单赋值 x = y += 加法赋值 x += y -= 减法赋值 x -= y *= 乘法赋值 x *= y /= 除法赋值 x /= y %= 取模赋值 x %= y 示例代码： int x = 10; x += 5; // x = x + 5, x 现在是 15 x -= 3; // x = x - 3, x 现在是 12 x *= 2; // x = x * 2, x 现在是 24 x /= 4; // x = x / 4, x 现在是 6 x %= 3; // x = x % 3, x 现在是 0 说明： 复合赋值操作符简化了代码，特别是在需要对变量进行多次修改时。 1.4 比较操作符\r比较操作符用于比较两个值，返回布尔值（true 或 false），常用于条件判断。 操作符 功能 示例 比较规则 ==/!= 相等/不等 \"abc\" == \"abc\"; // true 字符串比较内容，引用类型比较地址（除string） \u003e/\u003c 大于/小于 5 \u003e 3; // true 字符比较Unicode码值 \u003e=/\u003c= 大于等于/小于等于 4.5 \u003c= 4.5; // true 浮点数比较需考虑精度误差 示例代码： int a = 10; int b = 20; bool isEqual = (a == b); // false bool isNotEqual = (a != b); // true bool isGreater = (a \u003e b); // false bool isLess = (a \u003c b); // true 注意： 比较操作符常与控制流程语句（如 if）结合使用。 1.5 逻辑操作符\r逻辑操作符用于组合布尔表达式，常见于复杂条件判断。 操作符 名称 描述 \u0026\u0026 逻辑与 x \u0026\u0026 y ` ` ! 逻辑非 !x 示例代码： bool x = true; bool y = false; bool andResult = x \u0026\u0026 y; // false bool orResult = x || y; // true bool notResult = !x; // false 说明： 逻辑操作符具有短路求值特性：\u0026\u0026 在左侧为 false 时不计算右侧，|| 在左侧为 true 时不计算右侧。 1.6 位操作符\r位操作符用于操作整数的二进制位，适用于低级编程和性能优化。 操作符 功能 示例 \u0026 按位与 6 \u0026 3; // 2 (0b110 \u0026 0b011 = 0b010) ` ` 按位或 ^ 按位异或 6 ^ 3; // 5 (0b110 ^ 0b011 = 0b101) ~ 按位取反 ~6; // -7 (补码表示) \u003c\u003c/\u003e\u003e 左移/右移 4 \u003c\u003c 1; // 8 -4 \u003e\u003e 1; // -2 示例代码： int a = 5; // 二进制 0101 int b = 3; // 二进制 0011 int and = a \u0026 b; // 0001 -\u003e 1 int or = a | b; // 0111 -\u003e 7 int xor = a ^ b; // 0110 -\u003e 6 int notA = ~a; // 1010 (4位) -\u003e -6 (补码) int leftShift = a \u003c\u003c 1; // 1010 -\u003e 10 int rightShift = a \u003e\u003e 1; // 0010 -\u003e 2 注意： 位操作符在处理二进制数据、标志位等场景中非常有用。 1.7 其他操作符\rC#还包括一些特殊操作符，增强了代码的表达能力。 条件操作符（三元操作符）： 语法：condition ? true_expression : false_expression 示例： int age = 20; string status = (age \u003e= 18) ? \"Adult\" : \"Minor\"; // \"Adult\" 空合并操作符： 语法：x ?? y，若 x 为 null 则返回 y。 示例： string name = null; string displayName = name ?? \"Unknown\"; // \"Unknown\" 成员访问操作符：. 用于访问对象的成员。 示例： string length = \"hello\".Length; // 5 索引操作符：[] 用于访问数组或集合中的元素。 示例： int[] numbers = {1, 2, 3}; int first = numbers[0]; // 1 1.9 特殊操作符\rC# 还提供了一些其他特殊用途的操作符。 操作符 描述 示例 is 检查对象是否为特定类型 if (obj is string) as 执行引用转换，如果失败则返回 null string s = obj as string; new 创建新对象或调用构造函数 MyClass obj = new MyClass(); sizeof 获取类型在内存中的大小（以字节为单位） sizeof(int) typeof 获取指定类型的 System.Type 对象 Type t = typeof(string); 1.10 操作符优先级和结合性\r当一个表达式中包含多个操作符时，优先级决定了操作符的执行顺序。结合性则用于处理优先级相同的操作符，决定是从左到右还是从右到左进行计算。 优先级： 乘法 (*) 和除法 (/) 的优先级高于加法 (+) 和减法 (-)。 赋值操作符的优先级通常最低。 你可以使用括号 () 来强制改变运算顺序。 示例： int result = 5 + 3 * 2; // 结果为 11，因为先计算 3 * 2 int resultWithParentheses = (5 + 3) * 2; // 结果为 16，因为先计算括号中的 5 + 3 结合性： 大多数二元操作符（如 +, -, *, /）是左结合的，即从左到右计算。 赋值操作符（如 =) 和三元操作符 ?: 是右结合的，即从右到左计算。 2. 控制流程\r控制流程是决定程序执行顺序的关键。它允许你根据不同的条件执行不同的代码块，或者重复执行某段代码，是编写任何复杂程序的基石。C#主要有三大类控制流程语句：条件语句、循环语句和跳转语句。 2.1 条件语句 (Conditional Statements)\r条件语句用于根据某个布尔表达式的结果来决定执行哪个代码块。 if-else 语句\r这是最基本的条件语句，用于在条件为 true 或 false 时执行不同的代码。 int age = 20; if (age \u003e= 18) { Console.WriteLine(\"你已成年。\"); } else { Console.WriteLine(\"你未成年。\"); } 你可以使用 else if 来处理多个条件： int score = 85; if (score \u003e= 90) { Console.WriteLine(\"优秀\"); } else if (score \u003e= 80) { Console.WriteLine(\"良好\"); } else if (score \u003e= 60) { Console.WriteLine(\"及格\"); } else { Console.WriteLine(\"不及格\"); } switch 语句\r当你有多个针对同一变量的等值比较时，switch 语句比多个 if-else if 语句更简洁、更易读。 string day = \"Monday\"; switch (day) { case \"Mond","date":"2024-08-07","objectID":"/csharp/basic/7749b4b1-4b36-42d1-bd6c-14d264055cdb/:0:0","tags":["C#"],"title":"C#操作符和控制流程","uri":"/csharp/basic/7749b4b1-4b36-42d1-bd6c-14d264055cdb/"},{"categories":["C#基础"],"content":"1. C# 简介\rC# 是一种简单、现代、通用、面向对象的编程语言，由微软开发，旨在运行于 .NET 框架之上。它支持跨平台开发，适用于 Windows、macOS 和 Linux。C# 的设计目标包括类型安全、垃圾回收和丰富的类库，适合初学者快速上手。 历史与发展：C# 1.0 于 2002 年发布，最新版本为 C# 13（2024 年 11 月发布），与 .NET 9（2025 年 8 月 5 日发布）兼容。版本历史见 https://learn.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-version-history。 关键特性：自动垃圾回收、面向对象编程支持（封装、继承、多态）、强大的标准库、异步编程支持等。 2. 开发环境设置\r学习 C# 的第一步是设置开发环境。以下是详细步骤： 下载 .NET SDK：.NET SDK 是 C# 开发的核心组件。最新版本为 .NET 9.0.8（2025-08-05，标准支持）和 .NET 8.0.19（2025-08-05，长期支持）。下载地址：https://dotnet.microsoft.com/zh-cn/download。安装后，您可以通过命令行运行 dotnet --version 验证。 选择 IDE： Visual Studio Code：轻量级跨平台编辑器，适合初学者。下载地址：https://code.visualstudio.com/Download。安装 C# Dev Kit 扩展：https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csdevkit。 Visual Studio：功能强大的 IDE，适合 Windows 和 macOS 用户。下载地址：https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=Community\u0026rel=17。 在线编译器：如果不希望安装本地环境，可以使用在线工具，如菜鸟教程提供的编译器：https://www.runoob.com/try/showcs.php?filename=HelloWorld，适合初学者快速测试代码。 3. 基本语法\rC# 的基本语法包括变量声明、数据类型、运算符和控制结构。以下是详细内容： 3.1 Hello World 程序\r这是 C# 的入门程序，展示如何输出文本： using System; class Program { static void Main() { Console.WriteLine(\"Hello, World!\"); } } using System; 引入系统命名空间。 Main 是程序的入口点。 Console.WriteLine 用于输出文本到控制台。 从 Microsoft Learn 的交互式教程中，扩展学习包括字符串操作，如变量声明和插值： string aFriend = \"Bill\"; Console.WriteLine(aFriend); // 输出 Bill aFriend = \"Maira\"; Console.WriteLine($\"Hello {aFriend}\"); // 输出 Hello Maira 字符串方法如 Trim、Replace、ToUpper 等也非常实用，详见 https://learn.microsoft.com/zh-cn/dotnet/csharp/tour-of-csharp/tutorials/hello-world。 3.2 数据类型和变量\rC# 支持多种数据类型，初学者需掌握以下常见类型： 整型：int（32 位整数，如 int a = 18;），范围见 int.MaxValue 和 int.MinValue。 浮点型：double（双精度浮点数，如 double b = 4.5;），适合科学计算；decimal（高精度，如 decimal c = 1.0M;），用于金融计算。 字符串：string（如 string name = \"Alice\";），支持插值和方法如 Length、Contains。 数学运算示例： int a = 18; int b = 6; int c = a + b; // c = 24 Console.WriteLine(c); 注意溢出问题，如 int.MaxValue + 3 会导致负数结果，详见 https://learn.microsoft.com/zh-cn/dotnet/csharp/tour-of-csharp/tutorials/numbers。 3.3 运算符\rC# 支持算术运算符（+, -, *, /, %）、比较运算符（==, !=, \u003e, \u003c）和逻辑运算符（\u0026\u0026, ||, !）。运算顺序遵循数学规则，可用括号调整优先级。 示例： int d = a + b * c; // 先乘后加 int e = (a + b) % c; // 取余 3.4 控制结构\r控制结构包括条件判断和循环： if 语句： if (age \u003e= 18) { Console.WriteLine(\"成年人\"); } else { Console.WriteLine(\"未成年人\"); } switch 语句：用于多分支选择，示例见上文。 循环：for 循环示例： for (int i = 0; i \u003c 5; i++) { Console.WriteLine(i); // 输出 0 到 4 } 4. 面向对象编程\rC# 是面向对象的，支持封装、继承和多态。以下是详细介绍： 4.1 类和对象\r类是对象的蓝图，对象是类的实例。示例： public class Person { public string Name { get; set; } public int Age { get; set; } public void SayHello() { Console.WriteLine($\"你好，我叫 {Name}，今年 {Age} 岁。\"); } } 创建对象： Person person = new Person { Name = \"Alice\", Age = 30 }; person.SayHello(); // 输出：你好，我叫 Alice，今年 30 岁。 4.2 继承\r继承允许子类复用父类的属性和方法。示例： public class Student : Person { public string StudentId { get; set; } } 从 Microsoft Learn 的银行系统示例中，InterestEarningAccount 和 LineOfCreditAccount 继承自 BankAccount，利率分别为 2% 和 7%，详见 https://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/tutorials/oop。 4.3 多态\r多态通过 virtual 和 override 实现方法重写。示例： public class Animal { public virtual void MakeSound() { Console.WriteLine(\"动物叫\"); } } public class Dog : Animal { public override void MakeSound() { Console.WriteLine(\"汪汪\"); } } 4.4 封装\r通过访问修饰符（如 public、private）控制成员访问，保护内部实现。 5. 高级主题\r初学者可逐步学习以下高级主题： 异常处理：使用 try-catch 捕获异常，例如： try { int result = 10 / 0; } catch (DivideByZeroException e) { Console.WriteLine(\"除数不能为零：\" + e.Message); } 文件 I/O：读写文件，使用 System.IO 命名空间。 LINQ：语言集成查询，用于数据操作，示例见官方文档。 异步编程：使用 async 和 await 处理异步任务，适合网络操作。 6. 进一步学习资源\r以下是推荐的学习资源： 官方文档：https://learn.microsoft.com/zh-cn/dotnet/csharp/，提供交互式教程和参考资料。 在线教程：https://www.runoob.com/csharp/csharp-tutorial.html，适合初学者，包含在线编译器。 书籍：推荐《C# 7.0 核心技术指南》和《Head First C#》，深入学习高级概念。 社区与动态：关注 C# 技术大会（如 2025 年会议，主题为智能创新）和 GitHub 仓库（如 https://github.com/dotnet/csharplang），了解最新动态。 https://learn.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-version-history。 ","date":"2024-08-05","objectID":"/csharp/basic/d14b1543-d65d-40cb-a7c4-f3bed1e0dfc6/:0:0","tags":["C#"],"title":"C#概述","uri":"/csharp/basic/d14b1543-d65d-40cb-a7c4-f3bed1e0dfc6/"}]