[{"categories":["博客"],"content":"使用hugo new命令创建Markdown文件时，通常需要手动输入标题、日期等信息。为了简化这个过程，可以使用一个预设模板来自动生成Markdown文件的内容。 首先，你要有go环境，并安装github.com/google/uuid包来生成唯一的slug。 在目录中创建一个名为new_md.go的Go语言脚本，内容如下： package main import ( \"fmt\" \"os\" \"path/filepath\" \"strings\" \"time\" \"github.com/google/uuid\" ) const template = `--- title: \"%s\" date: %s slug: \"%s\" draft: true author: name: hobby link: https://github.com/haochan1996 email: espholychan@outllook.com avatar: https://avatars.githubusercontent.com/u/190246046?v=4 description: keywords: license: comment: false weight: 0 tags: - draft categories: - draft hiddenFromHomePage: false hiddenFromSearch: false hiddenFromRelated: false hiddenFromFeed: false summary: resources: - name: featured-image src: featured-image.jpg - name: featured-image-preview src: featured-image-preview.jpg toc: true math: false lightgallery: false password: message: repost: enable: true url: --- ## 标题二 正文内容... ` func main() { if len(os.Args) != 2 { fmt.Println(\"用法: go run py_new_md.go \u003c文件路径/文件名.md\u003e\") fmt.Println(\"请确保输入的路径存在且有效，可以使用相对或绝对路径。\") os.Exit(1) } filePath := os.Args[1] title := strings.TrimSuffix(filepath.Base(filePath), filepath.Ext(filePath)) dateStr := time.Now().Format(\"2006-01-02T15:04:05-0700\") slug := uuid.New().String() content := fmt.Sprintf(template, title, dateStr, slug) dir := filepath.Dir(filePath) // 检查目录是否存在，不存在则报错并退出 if _, err := os.Stat(dir); os.IsNotExist(err) { fmt.Printf(\"目录不存在: %s\\n\", dir) os.Exit(1) } if err := os.WriteFile(filePath, []byte(content), 0644); err != nil { fmt.Printf(\"写入文件失败: %v\\n\", err) os.Exit(1) } fmt.Printf(\"已生成: %s\\n\", filePath) } 当你运行这个脚本时，它会自动生成一个Markdown文件，包含预设的标题、日期、slug等信息。你只需要提供文件路径和文件名即可。你也可以根据实际的需求 修改模板内容。或者可以编译成可执行文件，方便使用。 // 使用方法： // go run new_md.go \u003c文件路径/文件名.md\u003e // 例如： go run new_md.go content/posts/创建预设模板内容的Markdown文件.md go run new_md.go content/csharp/wpf/布局控件.md ","date":"2025-08-05","objectID":"/posts/db9584e3-f61a-4ce4-9173-9f9a0369aee1/:0:0","tags":["博客"],"title":"创建预设模板内容的Markdown文件","uri":"/posts/db9584e3-f61a-4ce4-9173-9f9a0369aee1/"},{"categories":["draft"],"content":"C# 是一款开源且免费的编程语言，基于流行的 C 风格语法（如 C、C++、Java），让开发者可以快速上手。它强大的跨平台能力支持开发多样化的应用，包括桌面软件、Web 应用、移动应用、微服务、物联网设备和游戏主机平台。得益于其开源特性，开发者不仅能自由使用，还能查看、修改源代码，并向社区贡献改进。 C#语法基础\r关键字（Keywords）\rC#关键字是编译器保留的特殊单词，分为两类： 保留关键字：如 class、if、for、void 等，用于定义程序结构。 上下文关键字：如 var、async、await，仅在特定场景下被视为关键字。 关键作用： 声明类型（class、struct、enum） 控制流程（if、switch、while） 定义访问权限（public、private） 处理异常（try、catch） 示例： public class Program // 'public'和'class'为关键字 { static void Main() { if (true) { } // 'if'控制逻辑分支 } } 标识符（Identifiers）\r标识符是开发者自定义的名称（如变量、类名），规则如下： 组成：字母、数字、下划线_或@符号（@仅用于转义关键字，如 @class） 开头字符：字母或下划线（禁止数字开头） 大小写敏感：myVar 与 MyVar 不同 命名规范： 类名/方法名 → PascalCase（MyClass、CalculateSum()） 变量/参数名 → camelCase（userAge、isValid） 常量 → 全大写（MAX_SIZE） 示例： string firstName; // 变量：camelCase const int MAX_USERS = 100; // 常量：全大写 class CustomerOrder { } // 类名：PascalCase Main方法（Entry Point）\rMain 是程序执行的起点，必须满足： 固定签名：static void Main(string[] args)（args 可省略） 静态方法：用 static 修饰，无需实例化类 唯一性：每个程序仅允许一个 Main 方法1,3,10 示例： using System; class App { static void Main() // 入口方法 { Console.WriteLine(\"Hello, C#!\"); } } 语句与语句分隔符\r语句（Statements）：程序执行的最小单元，如： 声明语句：int x = 5; 赋值语句：x = 10; 控制流语句：if、for、return 分隔符： 分号 ;：标记语句结束（不可省略） 大括号 {}：定义代码块（如类体、循环体）4,5 示例： if (x \u003e 0) // if条件控制 { // 代码块开始 Console.WriteLine(x); return; // 返回语句 } // 代码块结束 空白（Whitespace）\r空白（空格、制表符、换行）用于提升代码可读性： 编译器忽略：不影响程序逻辑（如 int x=5; 等同 int x = 5;） 规范建议： 操作符两侧加空格（int sum = a + b;） 逗号后加空格（Method(arg1, arg2)） 缩进代码块（通常4个空格或1个制表符） 对比示例： // 紧凑写法（合法但难读） int x=5;if(x\u003e0){Console.WriteLine(x);} // 规范写法 int x = 5; if (x \u003e 0) { Console.WriteLine(x); } ","date":"2025-08-05","objectID":"/csharp/basic/d14b1543-d65d-40cb-a7c4-f3bed1e0dfc6/:0:0","tags":["draft"],"title":"C#概述","uri":"/csharp/basic/d14b1543-d65d-40cb-a7c4-f3bed1e0dfc6/"},{"categories":["WPF"],"content":"WPF 布局控件（继承自 Panel 类, 除了Border）通过测量（Measure）和排列（Arrange）两个阶段自动计算子元素的位置与尺寸，支持动态适应窗口大小变化。布局控件通过 Children 属性容纳子元素（如按钮、文本框等），支持嵌套组合实现复杂界面。 控件 布局方式 Grid 网格，根据自定义行和列来设置控件的布局 StackPanel 堆叠，包含的元素在垂直或水平方向排列 WrapPanel 流式布局，自动换行/列 DockPanel 边缘停靠+剩余填充 Canvas 画布，内部元素以像素为单位绝对坐标定位 UniformGrid 均分网格，相当于Grid的简化版，每个单元格的大小相同 Border 装饰的控件，用于绘制边框及背景，在Border中只能有一个子控件 Panel基类\rPanel 是 Windows Presentation Foundation（WPF）中提供布局支持的所有元素的基类。 Panel派生元素用于在可扩展应用程序标记语言（XAML）和代码中定位和排列元素。 WPF 包含一套全面的派生面板实现，可实现许多复杂布局。 这些派生类公开了启用大多数标准用户界面（UI）方案的属性和方法。 无法找到满足其需求的子排列行为的开发人员可以通过重写 ArrangeOverride 和 MeasureOverride 方法创建新的布局。 所有Panel元素都支持由FrameworkElement定义的基本大小调整和定位属性，包括Height、Width、HorizontalAlignment、VerticalAlignment和MarginLayoutTransform。 有关定位属性 FrameworkElement的其他信息，请参阅 对齐、边距和填充概述。 Panel 公开了在理解和使用布局时极为重要的附加属性。 该Background属性用于用一个Brush填充派生面板元素的边界之间的区域。 Children 表示由其 Panel 构成的元素的子集合。 InternalChildren 表示集合的内容 Children 以及数据绑定生成的成员。 两者都由父级UIElementCollection托管的子元素组成Panel。 面板还公开了一个 Panel.ZIndex 附加属性，该属性可用于在派生 Panel中实现分层顺序。 具有较高Children值的面板Panel.ZIndex集合的成员显示在值较低的Panel.ZIndex集合前面。 这对于面板特别有用，例如CanvasGrid，允许子元素共享相同的坐标空间。 Panel 还定义了 OnRender 方法，该方法可用于替代默认 Panel呈现行为。 Panel提供了GetZIndex和SetZIndex方法成员，分别表示获取某个元素的Zindex顺序和设置某个元素的ZIndex顺序。 什么是ZIndex?这是Panel提供的一个附加属性。假如一个单行单列的Grid布局控件中有两个Button,正常情况下，这两个Button都会以撑满Grid的方式星现在Grid中，那么，到底哪一个Button在上面，哪一个Button在下面呢?就看这两个Button的Panel.ZIndex附加属性的值，值越大越在上面，而值较小的那个Button将被上面的Button遮盖，从而在视觉上，用户只能看到一个Button。 Grid(网格布局)\r通过行（RowDefinitions）和列（ColumnDefinitions）定义表格结构，支持单元格合并与动态尺寸调整。 关键属性： Grid.Row / Grid.Column：指定子元素位置。 RowSpan / ColumnSpan：跨行/列。 ShowGridLines: 是否显示网格线 Grid的列宽与行高可采用固定、自动、按比例三种方式定义。 固定长度：值为一个确定的数字 自动长度：值为Auto，实际作用就是取实际控件所需的最小值 比例长度： *表示占用剩余的全部宽度；两行都是*，将平分剩余宽度; 一个2*，一个*，则前者占剩余全部宽度的2/3，后者占1/3; 示例： \u003cGrid\u003e \u003cGrid.RowDefinitions\u003e \u003c!--设置4行--\u003e \u003cRowDefinition Height=\"40\"\u003e\u003c/RowDefinition\u003e \u003cRowDefinition Height=\"Auto\"\u003e\u003c/RowDefinition\u003e \u003cRowDefinition Height=\"2*\"\u003e\u003c/RowDefinition\u003e \u003cRowDefinition Height=\"*\"\u003e\u003c/RowDefinition\u003e \u003c/Grid.RowDefinitions\u003e \u003cButton Grid.Row=\"0\" Content=\"Button 1\"\u003e\u003c/Button\u003e \u003cButton Grid.Row=\"1\" Content=\"Button 2\"\u003e\u003c/Button\u003e \u003cButton Grid.Row=\"2\" Content=\"Button 3\"\u003e\u003c/Button\u003e \u003cButton Grid.Row=\"3\" Content=\"Button 4\"\u003e\u003c/Button\u003e \u003c/Grid\u003e 效果： StackPanel(堆叠布局)\r子元素按单一方向（Orientation=\"Vertical\" 或 Horizontal\"）线性排列，不自动换行。默认方向是垂直排列（Orientation=\"Vertical\"），子元素从上到下堆叠。如果要设置水平排列，设置 Orientation=\"Horizontal\"，子元素从左到右排列。垂直布局时，子元素宽度默认拉伸至 StackPanel 的宽度，高度由内容决定（或显式设置）。水平布局时，子元素高度拉伸至 StackPanel 高度，宽度由内容决定。 StackPanel关键属性如下： 属性 说明 示例值 Orientation 排列方向：Vertical（默认）或 Horizontal Orientation=\"Horizontal\" Margin 容器外间距，控制与父容器的距离 Margin=\"10\" Padding 容器内边距，控制子元素与容器边界的距离 Padding=\"5\" Background 背景色（未设置时不响应鼠标事件） Background=\"LightGray\" HorizontalAlignment 容器在父容器中的水平对齐方式（Left/Center/Right/Stretch） HorizontalAlignment=\"Center\" VerticalAlignment 容器在父容器中的垂直对齐方式（Top/Center/Bottom/Stretch） VerticalAlignment=\"Top\" 布局嵌套\rStackPanel 可嵌套其他容器（如 Grid、嵌套的 StackPanel）实现复杂结构 \u003c!-- 垂直布局嵌套水平布局 --\u003e \u003cStackPanel Orientation=\"Vertical\"\u003e \u003cTextBlock Text=\"用户登录\"/\u003e \u003cStackPanel Orientation=\"Horizontal\"\u003e \u003c!-- 水平布局 --\u003e \u003cTextBlock Text=\"用户名：\" VerticalAlignment=\"Center\"/\u003e \u003cTextBox Width=\"200\"/\u003e \u003c/StackPanel\u003e \u003cButton Content=\"提交\"/\u003e \u003c/StackPanel\u003e 滚动支持\r通过 ScrollViewer 包裹 StackPanel 解决内容溢出问题 \u003cScrollViewer Height=\"150\"\u003e \u003cStackPanel\u003e \u003cButton Content=\"Item 1\" Height=\"40\"/\u003e \u003c!-- 更多子元素 --\u003e \u003c/StackPanel\u003e \u003c/ScrollViewer\u003e 动态操作子元素\r在代码中动态添加/删除子元素 // 添加按钮 private void AddButton_Click(object sender, RoutedEventArgs e) { Button newBtn = new Button { Content = \"New Button\" }; stackPanel.Children.Add(newBtn); } // 删除最后一个按钮 private void RemoveButton_Click(object sender, RoutedEventArgs e) { if (stackPanel.Children.Count \u003e 0) stackPanel.Children.RemoveAt(stackPanel.Children.Count - 1); } WrapPanel(流式布局)\rWrapPanel与StackPanel类似的功能, 相对于WrapPanel , 具有在有限的容器范围内, 可以自动换行, 或者换列处理。 具体则取决于WrapPanel的排列方式 (Orientation)： Orientation=\"Horizontal\"时各控件从左至右排列，当面板长度不够时，子控件就会自动换行，继续按照从左至右的顺序排列 Orientation=\"Vertical\"时各控件从上至下排列，当面板高度不够时，子控件就会自动换列，继续按照从上至下的顺序排列 示例： \u003cWrapPanel Orientation=\"Horizontal\"\u003e \u003cButton Content=\"Button 150\" Wid","date":"2025-08-05","objectID":"/csharp/wpf/64d18599-4cf7-40aa-b995-9cc111f50bd3/:0:0","tags":["WPF","C#"],"title":"布局控件","uri":"/csharp/wpf/64d18599-4cf7-40aa-b995-9cc111f50bd3/"},{"categories":null,"content":"网易云音乐歌单\r","date":"2025-08-04","objectID":"/music/8dd06b96-a944-4275-ab38-4afcb8b10160/:0:0","tags":null,"title":"","uri":"/music/8dd06b96-a944-4275-ab38-4afcb8b10160/"},{"categories":["WPF"],"content":"WPF概述\rWindows Presentation Foundation 桌面指南（WPF），这是一个独立于分辨率的 UI 框架，它使用基于矢量的呈现引擎，旨在利用现代图形硬件。 WPF 提供了一组全面的应用程序开发功能，其中包括可扩展应用程序标记语言（XAML）、控件、数据绑定、布局、2D 和 3D 图形、动画、样式、模板、文档、媒体、文本和版式。 WPF 是 .NET 的一部分，因此可以生成包含 .NET API 其他元素的应用程序。 WPF 有两个实现： .NET 版本（本指南）： .NET Framework 4 版本： 尽管.Net是一种跨平台技术，但是WPF仅能在Windows上运行。 什么是XAML？\rXAML 是基于 XML 的标记语言，以声明方式实现应用程序的外观。 通常使用它来定义窗口、对话框、页面和用户控件，并用控件、形状和图形填充它们。 以下示例使用 XAML 实现包含单个按钮的窗口的外观： \u003cWindow xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" Title=\"Window with button\" Width=\"250\" Height=\"100\"\u003e \u003c!-- Add button to window --\u003e \u003cButton Name=\"button\"\u003eClick Me!\u003c/Button\u003e \u003c/Window\u003e 具体而言，此 XAML 使用 Window 和 Button 元素定义窗口和按钮。 每个元素都配置了属性，例如 Window 元素的 Title 属性来指定窗口的标题栏文本。 在运行时，WPF 将标记中定义的元素和属性转换为 WPF 类的实例。 例如，Window 元素转换为 Window 类的实例，该类 Title 属性是 Title 特性的值。 下图显示了上一示例中 XAML 定义的用户界面（UI）： WPF的项目结构\r创建WPF应用程序。 App.xaml 与 App.xaml.cs 入口点：定义应用程序启动逻辑，通过StartupUri指定初始窗口（如StartupUri=“MainWindow.xaml”）。 全局资源：在\u003cApplication.Resources\u003e中定义样式、数据模板等资源，供整个应用复用。 生命周期事件：在App.xaml.cs中重写OnStartup()初始化服务，OnExit()执行清理逻辑，DispatcherUnhandledException捕获全局异常。 MainWindow.xaml 与 MainWindow.xaml.cs 主窗口UI：XAML文件定义布局和控件（如按钮、文本框）。 事件处理：代码文件（xaml.cs）实现交互逻辑（如按钮点击事件）。 App.xaml\rApp.xaml 是 WPF（Windows Presentation Foundation）应用程序的核心文件，承担着应用程序入口点、全局资源配置中心和生命周期事件处理器等关键角色。其核心作用可归纳为以下五类： 应用程序入口与启动控制\r启动窗口定义：通过StartupUri属性指定初始窗口（如 StartupUri=\"MainWindow.xaml\"），简化启动流程。 自定义启动逻辑：删除StartupUri后，可在App.xaml.cs中重写OnStartup 方法，实现动态初始化（如窗口预配置、参数解析、依赖注入容器初始化等操作）： protected override void OnStartup(StartupEventArgs e) { base.OnStartup(e); // 示例：解析启动参数 if (e.Args.Contains(\"debug\")) DebugMode.Enable(); // 动态创建主窗口 var mainWindow = new MainWindow(); mainWindow.Title = \"Custom Title\"; mainWindow.Show(); } 全局资源集中管理\r统一样式与模板：在\u003cApplication.Resources\u003e中定义应用级资源（样式、画笔、数据模板等），确保UI一致性： \u003cApplication.Resources\u003e \u003cStyle TargetType=\"Button\"\u003e \u003cSetter Property=\"Foreground\" Value=\"Red\"/\u003e \u003cSetter Property=\"FontSize\" Value=\"14\"/\u003e \u003c/Style\u003e \u003cResourceDictionary\u003e \u003cResourceDictionary.MergedDictionaries\u003e \u003cResourceDictionary Source=\"Styles/Icons.xaml\"/\u003e \u003c/ResourceDictionary.MergedDictionaries\u003e \u003c/ResourceDictionary\u003e \u003c/Application.Resources\u003e 多语言支持：通过合并不同语言的资源字典（如 en-us.xaml, zh-cn.xaml），实现动态切换界面语言。 应用程序生命周期管理\r关键事件处理： OnStartup：初始化全局状态（如数据库连接、配置加载）。 OnExit：执行清理任务（如保存用户数据、释放资源）。 OnSessionEnding：拦截系统关机/注销事件，提示未保存数据： protected override void OnSessionEnding(SessionEndingCancelEventArgs e) { if (HasUnsavedData) { e.Cancel = true; MessageBox.Show(\"数据未保存！\"); } } 未处理异常捕获：订阅 DispatcherUnhandledException 事件，防止崩溃并记录错误。 统一 UI 行为与线程管理\r全局样式生效范围：在App.xaml中定义的隐式样式（无x:Key）自动应用于所有匹配控件，无需显式引用。 UI 线程安全：通过Application.Current.Dispatcher.Invoke确保跨线程操作 UI 的安全性（但OnStartup中无需调用，因已在主线程）。 高级配置与扩展性\r关闭模式控制：ShutdownMode属性决定应用退出时机： OnLastWindowClose（默认）：所有窗口关闭后退出。 OnMainWindowClose：主窗口关闭即退出。 OnExplicitShutdown：需手动调用 Application.Current.Shutdown()。 依赖注入集成：在OnStartup中初始化容器（如 Unity、Autofac），注册全局服务： public static IUnityContainer Container; protected override void OnStartup(StartupEventArgs e) { Container = new UnityContainer(); Container.RegisterType\u003cIDataService, DataService\u003e(); base.OnStartup(e); } Application的生命周期\rWPF（Windows Presentation Foundation）应用程序的生命周期由 Application 类管理，涵盖从启动到关闭的全过程，开发者可通过重写方法或订阅事件介入关键节点。以下是核心阶段及关键行为的解析： 启动阶段（Startup）\r触发时机：应用程序入口点（Main 方法）调用 Application.Run() 后，主窗口显示前。 核心方法：OnStartup(StartupEventArgs e)： 用于初始化全局资源（如数据库连接、配置加载）、解析命令行参数（e.Args），或动态创建启动窗口（替代 StartupUri）。 protected override void OnStartup(StartupEventArgs e) { base.OnStartup(e); MainWindow = new CustomWindow(); // 动态创建主窗口 MainWindow.Show(); } 启动画面（Splash Screen）：通过添加图像文件并设置生成操作为 SplashScreen，实现启动瞬间显示初始界面。 原生SplashScreen实现，适用于静态图片场景，性能最优，由系统级 API 支持。 实现步骤： 添加图片资源 在项目中添加图片（支持 PNG、JPEG、BMP 等格式）。 属性设置：右键图片 → 生成操作 选 SplashScreen（VS 自动生成代码）。 代码控制显示逻辑（可选高级配置） protected override void OnStartup(StartupEventArgs e) { // 创建 SplashScreen 实例（图片路径需匹配资源名） var splash = new SplashScreen(\"SplashImage.png\"); // 非自动关闭 + 置顶显示 splash.Show(false, true); // 设置超时关闭（防止主窗口卡死导致 Splash 滞留） var timer = new Timer(_ =\u003e { Dispatcher.Invoke(() =\u003e splash.Close(TimeSpan","date":"2025-08-02","objectID":"/csharp/wpf/892c051/:0:0","tags":["WPF","C#"],"title":"WPF入门","uri":"/csharp/wpf/892c051/"}]