[{"categories":["WPF"],"content":"WPF 布局控件（继承自 Panel 类, 除了Border）通过测量（Measure）和排列（Arrange）两个阶段自动计算子元素的位置与尺寸，支持动态适应窗口大小变化。布局控件通过 Children 属性容纳子元素（如按钮、文本框等），支持嵌套组合实现复杂界面。 控件 布局方式 Grid 网格，根据自定义行和列来设置控件的布局 StackPanel 堆叠，包含的元素在垂直或水平方向排列 WrapPanel 流式布局，自动换行/列 DockPanel 边缘停靠+剩余填充 Canvas 画布，内部元素以像素为单位绝对坐标定位 UniformGrid 均分网格，相当于Grid的简化版，每个单元格的大小相同 Border 装饰的控件，用于绘制边框及背景，在Border中只能有一个子控件 Panel基类\rPanel 是 Windows Presentation Foundation（WPF）中提供布局支持的所有元素的基类。 Panel派生元素用于在可扩展应用程序标记语言（XAML）和代码中定位和排列元素。 WPF 包含一套全面的派生面板实现，可实现许多复杂布局。 这些派生类公开了启用大多数标准用户界面（UI）方案的属性和方法。 无法找到满足其需求的子排列行为的开发人员可以通过重写 ArrangeOverride 和 MeasureOverride 方法创建新的布局。 所有Panel元素都支持由FrameworkElement定义的基本大小调整和定位属性，包括Height、Width、HorizontalAlignment、VerticalAlignment和MarginLayoutTransform。 有关定位属性 FrameworkElement的其他信息，请参阅 对齐、边距和填充概述。 Panel 公开了在理解和使用布局时极为重要的附加属性。 该Background属性用于用一个Brush填充派生面板元素的边界之间的区域。 Children 表示由其 Panel 构成的元素的子集合。 InternalChildren 表示集合的内容 Children 以及数据绑定生成的成员。 两者都由父级UIElementCollection托管的子元素组成Panel。 面板还公开了一个 Panel.ZIndex 附加属性，该属性可用于在派生 Panel中实现分层顺序。 具有较高Children值的面板Panel.ZIndex集合的成员显示在值较低的Panel.ZIndex集合前面。 这对于面板特别有用，例如CanvasGrid，允许子元素共享相同的坐标空间。 Panel 还定义了 OnRender 方法，该方法可用于替代默认 Panel呈现行为。 Panel提供了GetZIndex和SetZIndex方法成员，分别表示获取某个元素的Zindex顺序和设置某个元素的ZIndex顺序。 什么是ZIndex?这是Panel提供的一个附加属性。假如一个单行单列的Grid布局控件中有两个Button,正常情况下，这两个Button都会以撑满Grid的方式星现在Grid中，那么，到底哪一个Button在上面，哪一个Button在下面呢?就看这两个Button的Panel.ZIndex附加属性的值，值越大越在上面，而值较小的那个Button将被上面的Button遮盖，从而在视觉上，用户只能看到一个Button。 Grid(网格布局)\r通过行（RowDefinitions）和列（ColumnDefinitions）定义表格结构，支持单元格合并与动态尺寸调整。 关键属性： Grid.Row / Grid.Column：指定子元素位置。 RowSpan / ColumnSpan：跨行/列。 ShowGridLines: 是否显示网格线 Grid的列宽与行高可采用固定、自动、按比例三种方式定义。 固定长度：值为一个确定的数字 自动长度：值为Auto，实际作用就是取实际控件所需的最小值 比例长度： *表示占用剩余的全部宽度；两行都是*，将平分剩余宽度; 一个2*，一个*，则前者占剩余全部宽度的2/3，后者占1/3; 示例： \u003cGrid\u003e \u003cGrid.RowDefinitions\u003e \u003c!--设置4行--\u003e \u003cRowDefinition Height=\"40\"\u003e\u003c/RowDefinition\u003e \u003cRowDefinition Height=\"Auto\"\u003e\u003c/RowDefinition\u003e \u003cRowDefinition Height=\"2*\"\u003e\u003c/RowDefinition\u003e \u003cRowDefinition Height=\"*\"\u003e\u003c/RowDefinition\u003e \u003c/Grid.RowDefinitions\u003e \u003cButton Grid.Row=\"0\" Content=\"Button 1\"\u003e\u003c/Button\u003e \u003cButton Grid.Row=\"1\" Content=\"Button 2\"\u003e\u003c/Button\u003e \u003cButton Grid.Row=\"2\" Content=\"Button 3\"\u003e\u003c/Button\u003e \u003cButton Grid.Row=\"3\" Content=\"Button 4\"\u003e\u003c/Button\u003e \u003c/Grid\u003e 效果： StackPanel(堆叠布局)\r子元素按单一方向（Orientation=\"Vertical\" 或 Horizontal\"）线性排列，不自动换行。默认方向是垂直排列（Orientation=\"Vertical\"），子元素从上到下堆叠。如果要设置水平排列，设置 Orientation=\"Horizontal\"，子元素从左到右排列。垂直布局时，子元素宽度默认拉伸至 StackPanel 的宽度，高度由内容决定（或显式设置）。水平布局时，子元素高度拉伸至 StackPanel 高度，宽度由内容决定。 StackPanel关键属性如下： 属性 说明 示例值 Orientation 排列方向：Vertical（默认）或 Horizontal Orientation=\"Horizontal\" Margin 容器外间距，控制与父容器的距离 Margin=\"10\" Padding 容器内边距，控制子元素与容器边界的距离 Padding=\"5\" Background 背景色（未设置时不响应鼠标事件） Background=\"LightGray\" HorizontalAlignment 容器在父容器中的水平对齐方式（Left/Center/Right/Stretch） HorizontalAlignment=\"Center\" VerticalAlignment 容器在父容器中的垂直对齐方式（Top/Center/Bottom/Stretch） VerticalAlignment=\"Top\" 布局嵌套\rStackPanel 可嵌套其他容器（如 Grid、嵌套的 StackPanel）实现复杂结构 \u003c!-- 垂直布局嵌套水平布局 --\u003e \u003cStackPanel Orientation=\"Vertical\"\u003e \u003cTextBlock Text=\"用户登录\"/\u003e \u003cStackPanel Orientation=\"Horizontal\"\u003e \u003c!-- 水平布局 --\u003e \u003cTextBlock Text=\"用户名：\" VerticalAlignment=\"Center\"/\u003e \u003cTextBox Width=\"200\"/\u003e \u003c/StackPanel\u003e \u003cButton Content=\"提交\"/\u003e \u003c/StackPanel\u003e 滚动支持\r通过 ScrollViewer 包裹 StackPanel 解决内容溢出问题 \u003cScrollViewer Height=\"150\"\u003e \u003cStackPanel\u003e \u003cButton Content=\"Item 1\" Height=\"40\"/\u003e \u003c!-- 更多子元素 --\u003e \u003c/StackPanel\u003e \u003c/ScrollViewer\u003e 动态操作子元素\r在代码中动态添加/删除子元素 // 添加按钮 private void AddButton_Click(object sender, RoutedEventArgs e) { Button newBtn = new Button { Content = \"New Button\" }; stackPanel.Children.Add(newBtn); } // 删除最后一个按钮 private void RemoveButton_Click(object sender, RoutedEventArgs e) { if (stackPanel.Children.Count \u003e 0) stackPanel.Children.RemoveAt(stackPanel.Children.Count - 1); } WrapPanel(流式布局)\rWrapPanel与StackPanel类似的功能, 相对于WrapPanel , 具有在有限的容器范围内, 可以自动换行, 或者换列处理。 具体则取决于WrapPanel的排列方式 (Orientation)： Orientation=\"Horizontal\"时各控件从左至右排列，当面板长度不够时，子控件就会自动换行，继续按照从左至右的顺序排列 Orientation=\"Vertical\"时各控件从上至下排列，当面板高度不够时，子控件就会自动换列，继续按照从上至下的顺序排列 示例： \u003cWrapPanel Orientation=\"Horizontal\"\u003e \u003cButton Content=\"Button 150\" Wid","date":"2025-08-05","objectID":"/csharp/wpf/64d18599-4cf7-40aa-b995-9cc111f50bd3/:0:0","tags":["WPF","C#"],"title":"WPF布局控件","uri":"/csharp/wpf/64d18599-4cf7-40aa-b995-9cc111f50bd3/"},{"categories":["C#基础"],"content":"1. 什么是数据类型？\r数据类型定义了变量可以存储的数据种类、占用内存的大小以及可以对变量执行的操作。C# 中的数据类型主要分为两类： 值类型 (Value Types)：直接存储数据，如整数、浮点数、布尔值等。 引用类型 (Reference Types)：存储数据的引用（内存地址），如字符串、数组、类等。 2. 值类型 (Value Types)\r值类型变量直接在栈内存中存储实际数据。以下是常见的内置值类型： 2.1 整数类型\r整数类型用于存储没有小数部分的数字。C# 提供多种整数类型，区别在于大小和是否支持负数： 类型 占用字节 范围 描述 byte 1 0 到 255 无符号 8 位整数 sbyte 1 -128 到 127 有符号 8 位整数 short 2 -32,768 到 32,767 有符号 16 位整数 ushort 2 0 到 65,535 无符号 16 位整数 int 4 -2,147,483,648 到 2,147,483,647 有符号 32 位整数 uint 4 0 到 4,294,967,295 无符号 32 位整数 long 8 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 有符号 64 位整数 ulong 8 0 到 18,446,744,073,709,551,615 无符号 64 位整数 示例代码： int age = 25; long bigNumber = 1234567890123L; // 使用 L 表示 long 类型 byte smallNumber = 255; 2.2 浮点类型\r浮点类型用于存储带小数部分的数字，适用于需要高精度的场景： 类型 占用字节 范围 精度 float 4 ±1.5e-45 到 ±3.4e38 7 位有效数字 double 8 ±5.0e-324 到 ±1.7e308 15-16 位有效数字 decimal 16 ±1.0e-28 到 ±7.9e28 28-29 位有效数字 注意： float 需要在数字后加 f（如 3.14f）。 decimal 需要加 m（如 3.14m），适合金融计算等高精度场景。 示例代码： float temperature = 36.6f; double pi = 3.14159265359; decimal balance = 12345.6789m; 2.3 布尔类型\rbool：占用 1 字节，值只能是 true 或 false。 用于逻辑判断。 示例代码： bool isStudent = true; bool hasLicense = false; 2.4 字符类型\rchar：占用 2 字节，存储单个 Unicode 字符（用单引号 '' 表示）。 示例代码： char grade = 'A'; char symbol = '\\u0041'; // Unicode 表示 'A' 2.5 结构体 (Struct)\r结构体是用户定义的值类型，包含多个字段。例如，System.DateTime 是一个结构体。 示例代码： struct Point { public int X; public int Y; } Point p = new Point { X = 10, Y = 20 }; 3. 引用类型 (Reference Types)\r引用类型变量存储的是数据的内存地址，数据本身存储在堆内存中。常见的引用类型包括： 3.1 字符串 (String)\rstring：表示不可变的 Unicode 字符序列。 使用双引号 \"\" 定义。 示例代码： string name = \"Alice\"; string greeting = $\"Hello, {name}!\"; // 字符串插值 3.2 数组 (Array)\r数组是固定大小的元素集合，元素类型必须一致。 示例代码： int[] numbers = new int[3] { 1, 2, 3 }; string[] names = { \"Alice\", \"Bob\", \"Charlie\" }; 3.3 元组（tuple）\rC#中的元组（Tuple）是一种数据结构，允许将多个不同类型的值组合成一个对象。 var person = (Name: \"John\", Age: 30); Console.WriteLine(person.Name); // 输出: John Console.WriteLine(person.Age); // 输出: 30 3.4 类 (Class)\r类是用户定义的引用类型，可以包含字段、属性、方法等。 示例代码： class Person { public string Name { get; set; } public int Age { get; set; } } Person person = new Person { Name = \"Bob\", Age = 30 }; 3.5 对象 (Object)\robject 是所有类型的基类，任何类型都可以转换为 object。 使用时需注意装箱和拆箱（见下文）。 示例代码： object obj = 42; // 装箱 int number = (int)obj; // 拆箱 4. 值类型与引用类型的区别\r特性 值类型 引用类型 存储位置 栈内存 堆内存（引用在栈中） 赋值行为 复制整个值 复制引用（指向同一对象） 默认值 0 或相应类型的默认值 null 示例 int, double, struct string, class, array 示例代码（值类型与引用类型的赋值行为）： int a = 10; int b = a; b = 20; // a 仍然是 10 Console.WriteLine(a); // 输出 10 string[] arr1 = { \"A\", \"B\" }; string[] arr2 = arr1; arr2[0] = \"C\"; // arr1[0] 也变为 \"C\" Console.WriteLine(arr1[0]); // 输出 C 5. 类型转换\rC# 中类型转换分为以下几种： 5.1 隐式转换\r低精度类型到高精度类型的自动转换，无需显式声明。 示例代码： int i = 100; double d = i; // 隐式转换 5.2 显式转换\r高精度类型到低精度类型需要强制转换，可能丢失数据。 示例代码： double d = 123.45; int i = (int)d; // 显式转换，i = 123 5.3 使用 Convert 类\rSystem.Convert 类提供多种类型转换方法。 示例代码： string str = \"123\"; int num = Convert.ToInt32(str); 5.4 使用 Parse 和 TryParse\rParse：将字符串转换为指定类型，若失败抛出异常。 TryParse：尝试转换，若失败返回 false，不抛异常。 示例代码： string str = \"123\"; int result; bool success = int.TryParse(str, out result); // success = true, result = 123 6. 装箱与拆箱 (Boxing and Unboxing)\r装箱：将值类型转换为 object 或接口类型，存储到堆内存。 拆箱：从 object 类型转换回值类型。 示例代码： int i = 42; object obj = i; // 装箱 int j = (int)obj; // 拆箱 注意：装箱和拆箱会影响性能，尽量避免在性能敏感的代码中使用。 7. 可空类型 (Nullable Types)\r值类型默认不能为 null，但可通过可空类型（如 int?）支持 null 值。 示例代码： int? nullableInt = null; if (nullableInt.HasValue) { Console.WriteLine(nullableInt.Value); } else { Console.WriteLine(\"Value is null\"); } 可空值类型简写： int? 等价于 Nullable\u003cint\u003e。 8. 动态类型 (Dynamic Type)\rdynamic 类型允许在运行时确定类型，绕过编译时类型检查。适用于与动态语言交互或未知类型的场景。 示例代码： dynamic value = 42; value = \"Now a string\"; // 动态类型允许更改类型 Console.WriteLine(value); 注意：使用 dynamic 会降低代码可读性和性能，建议谨慎使用。 9. 字面量 (Literals)\r字面量是直接在代码中书写的常量值，用于初始化变量或表示特定值。C# 支持多种类型的字面量，并允许使用前缀或后缀来指定数据类型或进制。 9.1 常见字面量类型\r整数字面量： 十进制：123 十六进制：0x7B（以 0x 开头） 二进制：0b01111011（以 0b 开头，C# 7.0+ 支持） 后缀：L（long）、UL（ulong）、U（uint）。 浮点字面量： 普通浮点：3.14 科学计数法：3.14e2（表示 3.14 × 10² = 314） 后缀：f（float）、d（double）、m（decimal）。 字符字面量：'A' 或 '\\u0041'（Unicode","date":"2024-08-07","objectID":"/csharp/basic/c6a99510-88ae-4d53-9fbb-a175cc2b0a07/:0:0","tags":["C#"],"title":"C#数据类型","uri":"/csharp/basic/c6a99510-88ae-4d53-9fbb-a175cc2b0a07/"},{"categories":["draft"],"content":"Control类\r定义:表示用户界面(UI)元素的基类，这些元素使用 ControlTemplate 来定义其外观。 Control是许多控件的基类。比如最常见的按钮(Button)、单选(RadioButton)、复选(CheckBox)、文本框(TextBox)、 ListBox、DataGrid、日期控件等等。这些控件通常用于展示程序的数据或获取用户输入的数据，我们可以将这一类型的控件称为内容控件或数据控件，它们与前面的布局控件有一定的区别，布局控件更专注于界面，而内容控件更专注于数据(业务)。 Control类虽然可以实例化，但是在界面上是不会有任何显示的。只有那些继承了Control的子类(控件)才会在界面上显示，而且所呈现的样子各不相同，为什么会是这样呢? 因为Control类提供了一个控件模板(ControlTemplate)，而几乎所有的子类都对这个ControlTemplate进行了各自的实现，所以在呈现子类时，我们才会看到Button拥有Button的样子，TextBox拥有TextBox的样子。 \u003cControl\u003e \u003cControl.Template\u003e \u003cControlTemplate TargetType=\"Control\"\u003e \u003cBorder Width=\"200\" Height=\"200\" Background=\"Red\" CornerRadius=\"100\"\u003e \u003cTextBlock Text=\"内容控件\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\" Foreground=\"White\" FontSize=\"24\"/\u003e \u003c/Border\u003e \u003c/ControlTemplate\u003e \u003c/Control.Template\u003e \u003c/Control\u003e 效果 控件属性\r属性名称 说明 字体与文本 FontFamily 设置控件的字体系列（如 Arial、微软雅黑）。 FontSize 设置字体大小（单位：设备无关像素）。 FontStyle 设置字体样式（如 Normal、Italic）。 FontWeight 设置字体粗细（如 Normal、Bold）。 FontStretch 控制字体拉伸程度（如 Condensed、Expanded）。 颜色与背景 Foreground 设置前景色（文本/图标颜色），类型为 Brush（支持纯色、渐变等）。 Background 设置背景色（控件内部填充色），类型为 Brush。 BorderBrush 设置边框颜色，类型为 Brush。 布局与尺寸 Width / Height 显式设置控件的宽度和高度（支持 Auto 自适应）。 MinWidth / MinHeight 设置控件的最小宽度/高度（约束尺寸范围）。 MaxWidth / MaxHeight 设置控件的最大宽度/高度。 Margin 设置控件的外边距（与其他元素的距离）。 Padding 设置控件的内边距（内容与边框的距离）。 内容对齐 HorizontalContentAlignment 设置内容的水平对齐方式（Left/Center/Right）。 VerticalContentAlignment 设置内容的垂直对齐方式（Top/Center/Bottom）。 边框设置 BorderThickness 设置边框的厚度（如 \"1\" 或 \"1,2,3,4\" 分方向设置）。 交互行为 IsTabStop 控制是否可通过 Tab 键导航到该控件（默认 True）。 TabIndex 设置 Tab 键导航时的顺序（数值越小优先级越高）。 Cursor 设置鼠标悬停时的光标样式（如 Hand、Wait）。 模板与样式 Template 定义控件的视觉模板（通过 ControlTemplate 完全自定义外观）。 Style 引用样式资源，批量设置属性值（如全局按钮样式）。 其他 ToolTip 设置鼠标悬停时的提示信息（支持富文本）。 ContextMenu 设置右键上下文菜单。 Visibility 控制可见性（Visible/Collapsed/Hidden）。 Opacity 设置透明度（0.0 完全透明 ~ 1.0 不透明）。 大部分的属性都比较好理解，这里着重介绍一下Template属性。属性 Template 是，ControlTemplate指定的外观 Control。如果要更改控件的外观但保留其功能，应考虑创建新 ControlTemplate 控件，而不是创建新类。如果把人比作是一个Control(控件)，那么”着装“就是Template(模板)。在大街上，我们会看到不同着装的人来来往往。 事件处理\r事件名称 触发时机 常见用途 生命周期事件 Initialized 控件初始化完成，属性已设置但尚未布局或渲染时触发。 初始化非依赖属性或执行早期配置。 Loaded 控件完成布局、数据绑定和渲染，可用于交互时触发。 加载数据、启动动画或执行依赖布局的逻辑。 Unloaded 控件从视觉树中移除时触发。 释放资源、取消订阅事件或清理后台任务。 鼠标事件 MouseEnter 鼠标指针进入控件边界时触发。 显示悬停提示（ToolTip）或高亮控件。 MouseLeave 鼠标指针离开控件边界时触发。 隐藏提示或恢复控件默认状态。 MouseLeftButtonDown 鼠标左键在控件上按下时触发（注意：Button 等控件默认抑制此事件）。 启动拖拽操作或自定义点击逻辑（需配合 e.Handled 处理）。 MouseLeftButtonUp 鼠标左键在控件上释放时触发。 完成拖拽或确认点击操作。 MouseMove 鼠标在控件上移动时持续触发。 实时追踪鼠标位置（如绘图工具）。 MouseDoubleClick 双击控件时触发（仅限 Control 派生类）。 快速编辑操作（如列表项双击打开详情）。 键盘事件 KeyDown 控件获得焦点且键盘按键按下时触发。 捕获快捷键（如 Enter 提交表单）。 KeyUp 控件获得焦点且键盘按键释放时触发。 响应按键释放后的状态更新。 焦点事件 GotFocus 控件获得逻辑焦点时触发。 激活编辑模式或显示辅助UI。 LostFocus 控件失去逻辑焦点时触发。 验证输入数据或保存编辑内容。 拖拽事件 DragEnter 拖拽对象进入控件边界时触发（需设置 AllowDrop=\"True\"）。 检查拖拽数据类型并显示视觉反馈（如高亮边框）。 DragOver 拖拽对象在控件上移动时持续触发。 动态更新拖拽位置（如实时调整插入点）。 Drop 拖拽对象在控件上释放时触发。 处理拖拽数据（如文件导入或控件重定位）。 WPF 的 Control 事件基于路由事件模型，分为冒泡路由（从子控件向父容器传递）和隧道路由（从父容器向子控件传递，以 Preview 前缀标识，如 PreviewMouseLeftButtonDown）。实际应用中需注意： 事件抑制：部分控件（如Button）会标记e.Handled=true抑制底层事件（如MouseLeftButtonDown），此时需改用Preview事件或显式调用AddHandler。 拖拽必要条件：接收拖拽事件的控件必须设置AllowDrop=\"True\"且Background非null（建议设为 Transparent）。 性能优化：高频事件（如 MouseMove）中避免复杂逻辑，或使用去抖机制（Debounce）减少处理频率。 命令与行为：为解耦 UI 与逻辑，建议将事件处理封装为 Behavior（如拖拽行为）或绑定到 ICommand 实现 MVVM 模式。 ControlContent（内容控件）\rContentControl是WPF中用于承载任意类型内容的基类，其核心是通过Content 属性动态显示数据或UI元素。 核心特性\r内容灵活性：Content 属性类型为 object，可接受字符串、图像、其他控件（如 Button）甚至复杂数据对象。 模板化支持：通过 ContentTemplate 属性自定义内容的视觉呈现方式（如将数据对象转换为富文本布局）。 数据绑定：支持将 Content 绑定到数据源（如数据库字段、XML 节点），实现动态更新。 自定义内容模板\r将数据对象转换为复杂 UI（如员工卡片） \u003cContentControl Content=\"{Binding Employee}\"\u003e \u003cContentControl.ContentTemplate\u003e \u003cDataTemplate\u003e \u003cStackPanel\u003e \u003cImage Source=\"{Binding Avatar}\" Width=\"50\"/\u003e \u003cTextBlock Text=\"{Binding Name}\" FontWeight=\"Bold\"/\u003e \u003c/StackPanel\u003e \u003c/DataTemplate\u003e \u003c/ContentControl.ContentTemplate\u003e \u003c/ContentControl\u003e Button(按钮控件)\rButton继承自ButtonBase，是用户交互的核心控件，用于触发命令或事件。 核心属性详解\r属性 说明 示例 Content 按钮显示内容（支持任意对象） \u003cButton Content=\"提交\"/\u003e 或 \u003cButton\u003e \u003cImage Source=\"icon.png\"/\u003e \u003c/Button\u003e Command 绑定执行命令（如 SaveCommand） \u003cButt","date":"2025-08-06","objectID":"/csharp/wpf/5f4d026a-d256-4989-a4e0-7399716779bd/:0:0","tags":["draft"],"title":"WPF内容控件","uri":"/csharp/wpf/5f4d026a-d256-4989-a4e0-7399716779bd/"},{"categories":["博客"],"content":"使用hugo new命令创建Markdown文件时，通常需要手动输入标题、日期等信息。为了简化这个过程，可以使用一个预设模板来自动生成Markdown文件的内容。 首先，你要有go环境，并安装github.com/google/uuid包来生成唯一的slug。 在目录中创建一个名为new_md.go的Go语言脚本，内容如下： package main import ( \"fmt\" \"os\" \"path/filepath\" \"strings\" \"time\" \"github.com/google/uuid\" ) const template = `--- title: \"%s\" date: %s slug: \"%s\" draft: true author: name: hobby link: https://github.com/haochan1996 email: espholychan@outllook.com avatar: https://avatars.githubusercontent.com/u/190246046?v=4 description: keywords: license: comment: false weight: 0 tags: - draft categories: - draft hiddenFromHomePage: false hiddenFromSearch: false hiddenFromRelated: false hiddenFromFeed: false summary: resources: - name: featured-image src: featured-image.jpg - name: featured-image-preview src: featured-image-preview.jpg toc: true math: false lightgallery: false password: message: repost: enable: true url: --- ## 标题二 正文内容... ` func main() { if len(os.Args) != 2 { fmt.Println(\"用法: go run py_new_md.go \u003c文件路径/文件名.md\u003e\") fmt.Println(\"请确保输入的路径存在且有效，可以使用相对或绝对路径。\") os.Exit(1) } filePath := os.Args[1] title := strings.TrimSuffix(filepath.Base(filePath), filepath.Ext(filePath)) dateStr := time.Now().Format(\"2006-01-02T15:04:05-0700\") slug := uuid.New().String() content := fmt.Sprintf(template, title, dateStr, slug) dir := filepath.Dir(filePath) // 检查目录是否存在，不存在则报错并退出 if _, err := os.Stat(dir); os.IsNotExist(err) { fmt.Printf(\"目录不存在: %s\\n\", dir) os.Exit(1) } if err := os.WriteFile(filePath, []byte(content), 0644); err != nil { fmt.Printf(\"写入文件失败: %v\\n\", err) os.Exit(1) } fmt.Printf(\"已生成: %s\\n\", filePath) } 当你运行这个脚本时，它会自动生成一个Markdown文件，包含预设的标题、日期、slug等信息。你只需要提供文件路径和文件名即可。你也可以根据实际的需求 修改模板内容。或者可以编译成可执行文件，方便使用。 // 使用方法： // go run new_md.go \u003c文件路径/文件名.md\u003e // 例如： go run new_md.go content/posts/创建预设模板内容的Markdown文件.md go run new_md.go content/csharp/wpf/布局控件.md ","date":"2025-08-05","objectID":"/posts/db9584e3-f61a-4ce4-9173-9f9a0369aee1/:0:0","tags":["博客"],"title":"创建预设模板内容的Markdown文件","uri":"/posts/db9584e3-f61a-4ce4-9173-9f9a0369aee1/"},{"categories":null,"content":"网易云音乐歌单\r","date":"2025-08-04","objectID":"/music/8dd06b96-a944-4275-ab38-4afcb8b10160/:0:0","tags":null,"title":"","uri":"/music/8dd06b96-a944-4275-ab38-4afcb8b10160/"},{"categories":["WPF"],"content":"WPF概述\rWindows Presentation Foundation 桌面指南（WPF），这是一个独立于分辨率的 UI 框架，它使用基于矢量的呈现引擎，旨在利用现代图形硬件。 WPF 提供了一组全面的应用程序开发功能，其中包括可扩展应用程序标记语言（XAML）、控件、数据绑定、布局、2D 和 3D 图形、动画、样式、模板、文档、媒体、文本和版式。 WPF 是 .NET 的一部分，因此可以生成包含 .NET API 其他元素的应用程序。 WPF 有两个实现： .NET 版本（本指南）： .NET Framework 4 版本： 尽管.Net是一种跨平台技术，但是WPF仅能在Windows上运行。 什么是XAML？\rXAML 是基于 XML 的标记语言，以声明方式实现应用程序的外观。 通常使用它来定义窗口、对话框、页面和用户控件，并用控件、形状和图形填充它们。 以下示例使用 XAML 实现包含单个按钮的窗口的外观： \u003cWindow xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" Title=\"Window with button\" Width=\"250\" Height=\"100\"\u003e \u003c!-- Add button to window --\u003e \u003cButton Name=\"button\"\u003eClick Me!\u003c/Button\u003e \u003c/Window\u003e 具体而言，此 XAML 使用 Window 和 Button 元素定义窗口和按钮。 每个元素都配置了属性，例如 Window 元素的 Title 属性来指定窗口的标题栏文本。 在运行时，WPF 将标记中定义的元素和属性转换为 WPF 类的实例。 例如，Window 元素转换为 Window 类的实例，该类 Title 属性是 Title 特性的值。 下图显示了上一示例中 XAML 定义的用户界面（UI）： WPF的项目结构\r创建WPF应用程序。 App.xaml 与 App.xaml.cs 入口点：定义应用程序启动逻辑，通过StartupUri指定初始窗口（如StartupUri=“MainWindow.xaml”）。 全局资源：在\u003cApplication.Resources\u003e中定义样式、数据模板等资源，供整个应用复用。 生命周期事件：在App.xaml.cs中重写OnStartup()初始化服务，OnExit()执行清理逻辑，DispatcherUnhandledException捕获全局异常。 MainWindow.xaml 与 MainWindow.xaml.cs 主窗口UI：XAML文件定义布局和控件（如按钮、文本框）。 事件处理：代码文件（xaml.cs）实现交互逻辑（如按钮点击事件）。 App.xaml\rApp.xaml 是 WPF（Windows Presentation Foundation）应用程序的核心文件，承担着应用程序入口点、全局资源配置中心和生命周期事件处理器等关键角色。其核心作用可归纳为以下五类： 应用程序入口与启动控制\r启动窗口定义：通过StartupUri属性指定初始窗口（如 StartupUri=\"MainWindow.xaml\"），简化启动流程。 自定义启动逻辑：删除StartupUri后，可在App.xaml.cs中重写OnStartup 方法，实现动态初始化（如窗口预配置、参数解析、依赖注入容器初始化等操作）： protected override void OnStartup(StartupEventArgs e) { base.OnStartup(e); // 示例：解析启动参数 if (e.Args.Contains(\"debug\")) DebugMode.Enable(); // 动态创建主窗口 var mainWindow = new MainWindow(); mainWindow.Title = \"Custom Title\"; mainWindow.Show(); } 全局资源集中管理\r统一样式与模板：在\u003cApplication.Resources\u003e中定义应用级资源（样式、画笔、数据模板等），确保UI一致性： \u003cApplication.Resources\u003e \u003cStyle TargetType=\"Button\"\u003e \u003cSetter Property=\"Foreground\" Value=\"Red\"/\u003e \u003cSetter Property=\"FontSize\" Value=\"14\"/\u003e \u003c/Style\u003e \u003cResourceDictionary\u003e \u003cResourceDictionary.MergedDictionaries\u003e \u003cResourceDictionary Source=\"Styles/Icons.xaml\"/\u003e \u003c/ResourceDictionary.MergedDictionaries\u003e \u003c/ResourceDictionary\u003e \u003c/Application.Resources\u003e 多语言支持：通过合并不同语言的资源字典（如 en-us.xaml, zh-cn.xaml），实现动态切换界面语言。 应用程序生命周期管理\r关键事件处理： OnStartup：初始化全局状态（如数据库连接、配置加载）。 OnExit：执行清理任务（如保存用户数据、释放资源）。 OnSessionEnding：拦截系统关机/注销事件，提示未保存数据： protected override void OnSessionEnding(SessionEndingCancelEventArgs e) { if (HasUnsavedData) { e.Cancel = true; MessageBox.Show(\"数据未保存！\"); } } 未处理异常捕获：订阅 DispatcherUnhandledException 事件，防止崩溃并记录错误。 统一 UI 行为与线程管理\r全局样式生效范围：在App.xaml中定义的隐式样式（无x:Key）自动应用于所有匹配控件，无需显式引用。 UI 线程安全：通过Application.Current.Dispatcher.Invoke确保跨线程操作 UI 的安全性（但OnStartup中无需调用，因已在主线程）。 高级配置与扩展性\r关闭模式控制：ShutdownMode属性决定应用退出时机： OnLastWindowClose（默认）：所有窗口关闭后退出。 OnMainWindowClose：主窗口关闭即退出。 OnExplicitShutdown：需手动调用 Application.Current.Shutdown()。 依赖注入集成：在OnStartup中初始化容器（如 Unity、Autofac），注册全局服务： public static IUnityContainer Container; protected override void OnStartup(StartupEventArgs e) { Container = new UnityContainer(); Container.RegisterType\u003cIDataService, DataService\u003e(); base.OnStartup(e); } Application的生命周期\rWPF（Windows Presentation Foundation）应用程序的生命周期由 Application 类管理，涵盖从启动到关闭的全过程，开发者可通过重写方法或订阅事件介入关键节点。以下是核心阶段及关键行为的解析： 启动阶段（Startup）\r触发时机：应用程序入口点（Main 方法）调用 Application.Run() 后，主窗口显示前。 核心方法：OnStartup(StartupEventArgs e)： 用于初始化全局资源（如数据库连接、配置加载）、解析命令行参数（e.Args），或动态创建启动窗口（替代 StartupUri）。 protected override void OnStartup(StartupEventArgs e) { base.OnStartup(e); MainWindow = new CustomWindow(); // 动态创建主窗口 MainWindow.Show(); } 启动画面（Splash Screen）：通过添加图像文件并设置生成操作为 SplashScreen，实现启动瞬间显示初始界面。 原生SplashScreen实现，适用于静态图片场景，性能最优，由系统级 API 支持。 实现步骤： 添加图片资源 在项目中添加图片（支持 PNG、JPEG、BMP 等格式）。 属性设置：右键图片 → 生成操作 选 SplashScreen（VS 自动生成代码）。 代码控制显示逻辑（可选高级配置） protected override void OnStartup(StartupEventArgs e) { // 创建 SplashScreen 实例（图片路径需匹配资源名） var splash = new SplashScreen(\"SplashImage.png\"); // 非自动关闭 + 置顶显示 splash.Show(false, true); // 设置超时关闭（防止主窗口卡死导致 Splash 滞留） var timer = new Timer(_ =\u003e { Dispatcher.Invoke(() =\u003e splash.Close(TimeSpan","date":"2025-08-02","objectID":"/csharp/wpf/892c051/:0:0","tags":["WPF","C#"],"title":"WPF入门","uri":"/csharp/wpf/892c051/"},{"categories":["draft"],"content":"1.操作符\r1.1 概述\r操作符是用于执行特定操作的符号，例如算术、比较、逻辑等。根据操作数的数量，操作符可以分为： 一元操作符：作用于一个操作数，如 -x（取反）。 二元操作符：作用于两个操作数，如 x + y。 三元操作符：作用于三个操作数，如条件操作符 condition ? true_value : false_value。 2.1 算术操作符\r算术操作符用于执行基本的数学计算，适用于数值类型（如 int、double 等）。 操作符 功能 示例 注意事项 + 加法/字符串拼接 int c = 3 + 5; string s = \"a\" + \"b\"; 字符串拼接产生新对象 - 减法 double d = 5.0 - 2.0; // 3.0 不支持ulong取负 * 乘法 float f = 2.5f * 2; // 5.0 整数乘法溢出时截断高位 / 除法 int i = 7 / 2; // 3 double k = 7.0 / 2; // 3.5 整数除法舍去小数 % 取余 int r = 10 % 3; // 1 余数符号与被除数相同 ++/-- 自增/自减 int x = 1; x++; // 2 前缀先运算后返回值，后缀反之 示例代码： int a = 10; int b = 5; int sum = a + b; // 15 int difference = a - b; // 5 int product = a * b; // 50 int quotient = a / b; // 2 int remainder = a % b; // 0 a++; // a 现在是 11 b--; // b 现在是 4 注意： 自增和自减操作符有前置（++x）和后置（x++）之分。前置先执行操作再返回值，后置先返回值再执行操作。 1.3 赋值操作符\r赋值操作符用于将值赋给变量，常见的包括简单赋值和复合赋值。 操作符 描述 示例 = 简单赋值 x = y += 加法赋值 x += y -= 减法赋值 x -= y *= 乘法赋值 x *= y /= 除法赋值 x /= y %= 取模赋值 x %= y 示例代码： int x = 10; x += 5; // x = x + 5, x 现在是 15 x -= 3; // x = x - 3, x 现在是 12 x *= 2; // x = x * 2, x 现在是 24 x /= 4; // x = x / 4, x 现在是 6 x %= 3; // x = x % 3, x 现在是 0 说明： 复合赋值操作符简化了代码，特别是在需要对变量进行多次修改时。 1.4 比较操作符\r比较操作符用于比较两个值，返回布尔值（true 或 false），常用于条件判断。 操作符 功能 示例 比较规则 ==/!= 相等/不等 \"abc\" == \"abc\"; // true 字符串比较内容，引用类型比较地址（除string） \u003e/\u003c 大于/小于 5 \u003e 3; // true 字符比较Unicode码值 \u003e=/\u003c= 大于等于/小于等于 4.5 \u003c= 4.5; // true 浮点数比较需考虑精度误差 示例代码： int a = 10; int b = 20; bool isEqual = (a == b); // false bool isNotEqual = (a != b); // true bool isGreater = (a \u003e b); // false bool isLess = (a \u003c b); // true 注意： 比较操作符常与控制流程语句（如 if）结合使用。 1.5 逻辑操作符\r逻辑操作符用于组合布尔表达式，常见于复杂条件判断。 操作符 名称 描述 \u0026\u0026 逻辑与 x \u0026\u0026 y ` ` ! 逻辑非 !x 示例代码： bool x = true; bool y = false; bool andResult = x \u0026\u0026 y; // false bool orResult = x || y; // true bool notResult = !x; // false 说明： 逻辑操作符具有短路求值特性：\u0026\u0026 在左侧为 false 时不计算右侧，|| 在左侧为 true 时不计算右侧。 1.6 位操作符\r位操作符用于操作整数的二进制位，适用于低级编程和性能优化。 操作符 功能 示例 \u0026 按位与 6 \u0026 3; // 2 (0b110 \u0026 0b011 = 0b010) ` ` 按位或 ^ 按位异或 6 ^ 3; // 5 (0b110 ^ 0b011 = 0b101) ~ 按位取反 ~6; // -7 (补码表示) \u003c\u003c/\u003e\u003e 左移/右移 4 \u003c\u003c 1; // 8 -4 \u003e\u003e 1; // -2 示例代码： int a = 5; // 二进制 0101 int b = 3; // 二进制 0011 int and = a \u0026 b; // 0001 -\u003e 1 int or = a | b; // 0111 -\u003e 7 int xor = a ^ b; // 0110 -\u003e 6 int notA = ~a; // 1010 (4位) -\u003e -6 (补码) int leftShift = a \u003c\u003c 1; // 1010 -\u003e 10 int rightShift = a \u003e\u003e 1; // 0010 -\u003e 2 注意： 位操作符在处理二进制数据、标志位等场景中非常有用。 1.7 其他操作符\rC#还包括一些特殊操作符，增强了代码的表达能力。 条件操作符（三元操作符）： 语法：condition ? true_expression : false_expression 示例： int age = 20; string status = (age \u003e= 18) ? \"Adult\" : \"Minor\"; // \"Adult\" 空合并操作符： 语法：x ?? y，若 x 为 null 则返回 y。 示例： string name = null; string displayName = name ?? \"Unknown\"; // \"Unknown\" 成员访问操作符：. 用于访问对象的成员。 示例： string length = \"hello\".Length; // 5 索引操作符：[] 用于访问数组或集合中的元素。 示例： int[] numbers = {1, 2, 3}; int first = numbers[0]; // 1 1.9 特殊操作符\rC# 还提供了一些其他特殊用途的操作符。 操作符 描述 示例 is 检查对象是否为特定类型 if (obj is string) as 执行引用转换，如果失败则返回 null string s = obj as string; new 创建新对象或调用构造函数 MyClass obj = new MyClass(); sizeof 获取类型在内存中的大小（以字节为单位） sizeof(int) typeof 获取指定类型的 System.Type 对象 Type t = typeof(string); 1.10 操作符优先级和结合性\r当一个表达式中包含多个操作符时，优先级决定了操作符的执行顺序。结合性则用于处理优先级相同的操作符，决定是从左到右还是从右到左进行计算。 优先级： 乘法 (*) 和除法 (/) 的优先级高于加法 (+) 和减法 (-)。 赋值操作符的优先级通常最低。 你可以使用括号 () 来强制改变运算顺序。 示例： int result = 5 + 3 * 2; // 结果为 11，因为先计算 3 * 2 int resultWithParentheses = (5 + 3) * 2; // 结果为 16，因为先计算括号中的 5 + 3 结合性： 大多数二元操作符（如 +, -, *, /）是左结合的，即从左到右计算。 赋值操作符（如 =) 和三元操作符 ?: 是右结合的，即从右到左计算。 2. 控制流程\r控制流程是决定程序执行顺序的关键。它允许你根据不同的条件执行不同的代码块，或者重复执行某段代码，是编写任何复杂程序的基石。C#主要有三大类控制流程语句：条件语句、循环语句和跳转语句。 2.1 条件语句 (Conditional Statements)\r条件语句用于根据某个布尔表达式的结果来决定执行哪个代码块。 if-else 语句\r这是最基本的条件语句，用于在条件为 true 或 false 时执行不同的代码。 int age = 20; if (age \u003e= 18) { Console.WriteLine(\"你已成年。\"); } else { Console.WriteLine(\"你未成年。\"); } 你可以使用 else if 来处理多个条件： int score = 85; if (score \u003e= 90) { Console.WriteLine(\"优秀\"); } else if (score \u003e= 80) { Console.WriteLine(\"良好\"); } else if (score \u003e= 60) { Console.WriteLine(\"及格\"); } else { Console.WriteLine(\"不及格\"); } switch 语句\r当你有多个针对同一变量的等值比较时，switch 语句比多个 if-else if 语句更简洁、更易读。 string day = \"Monday\"; switch (day) { case \"Mond","date":"2024-08-07","objectID":"/csharp/basic/7749b4b1-4b36-42d1-bd6c-14d264055cdb/:0:0","tags":["draft"],"title":"C#操作符和控制流程","uri":"/csharp/basic/7749b4b1-4b36-42d1-bd6c-14d264055cdb/"},{"categories":["C#基础"],"content":"1. C# 简介\rC# 是一种简单、现代、通用、面向对象的编程语言，由微软开发，旨在运行于 .NET 框架之上。它支持跨平台开发，适用于 Windows、macOS 和 Linux。C# 的设计目标包括类型安全、垃圾回收和丰富的类库，适合初学者快速上手。 历史与发展：C# 1.0 于 2002 年发布，最新版本为 C# 13（2024 年 11 月发布），与 .NET 9（2025 年 8 月 5 日发布）兼容。版本历史见 https://learn.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-version-history。 关键特性：自动垃圾回收、面向对象编程支持（封装、继承、多态）、强大的标准库、异步编程支持等。 2. 开发环境设置\r学习 C# 的第一步是设置开发环境。以下是详细步骤： 下载 .NET SDK：.NET SDK 是 C# 开发的核心组件。最新版本为 .NET 9.0.8（2025-08-05，标准支持）和 .NET 8.0.19（2025-08-05，长期支持）。下载地址：https://dotnet.microsoft.com/zh-cn/download。安装后，您可以通过命令行运行 dotnet --version 验证。 选择 IDE： Visual Studio Code：轻量级跨平台编辑器，适合初学者。下载地址：https://code.visualstudio.com/Download。安装 C# Dev Kit 扩展：https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csdevkit。 Visual Studio：功能强大的 IDE，适合 Windows 和 macOS 用户。下载地址：https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=Community\u0026rel=17。 在线编译器：如果不希望安装本地环境，可以使用在线工具，如菜鸟教程提供的编译器：https://www.runoob.com/try/showcs.php?filename=HelloWorld，适合初学者快速测试代码。 3. 基本语法\rC# 的基本语法包括变量声明、数据类型、运算符和控制结构。以下是详细内容： 3.1 Hello World 程序\r这是 C# 的入门程序，展示如何输出文本： using System; class Program { static void Main() { Console.WriteLine(\"Hello, World!\"); } } using System; 引入系统命名空间。 Main 是程序的入口点。 Console.WriteLine 用于输出文本到控制台。 从 Microsoft Learn 的交互式教程中，扩展学习包括字符串操作，如变量声明和插值： string aFriend = \"Bill\"; Console.WriteLine(aFriend); // 输出 Bill aFriend = \"Maira\"; Console.WriteLine($\"Hello {aFriend}\"); // 输出 Hello Maira 字符串方法如 Trim、Replace、ToUpper 等也非常实用，详见 https://learn.microsoft.com/zh-cn/dotnet/csharp/tour-of-csharp/tutorials/hello-world。 3.2 数据类型和变量\rC# 支持多种数据类型，初学者需掌握以下常见类型： 整型：int（32 位整数，如 int a = 18;），范围见 int.MaxValue 和 int.MinValue。 浮点型：double（双精度浮点数，如 double b = 4.5;），适合科学计算；decimal（高精度，如 decimal c = 1.0M;），用于金融计算。 字符串：string（如 string name = \"Alice\";），支持插值和方法如 Length、Contains。 数学运算示例： int a = 18; int b = 6; int c = a + b; // c = 24 Console.WriteLine(c); 注意溢出问题，如 int.MaxValue + 3 会导致负数结果，详见 https://learn.microsoft.com/zh-cn/dotnet/csharp/tour-of-csharp/tutorials/numbers。 3.3 运算符\rC# 支持算术运算符（+, -, *, /, %）、比较运算符（==, !=, \u003e, \u003c）和逻辑运算符（\u0026\u0026, ||, !）。运算顺序遵循数学规则，可用括号调整优先级。 示例： int d = a + b * c; // 先乘后加 int e = (a + b) % c; // 取余 3.4 控制结构\r控制结构包括条件判断和循环： if 语句： if (age \u003e= 18) { Console.WriteLine(\"成年人\"); } else { Console.WriteLine(\"未成年人\"); } switch 语句：用于多分支选择，示例见上文。 循环：for 循环示例： for (int i = 0; i \u003c 5; i++) { Console.WriteLine(i); // 输出 0 到 4 } 4. 面向对象编程\rC# 是面向对象的，支持封装、继承和多态。以下是详细介绍： 4.1 类和对象\r类是对象的蓝图，对象是类的实例。示例： public class Person { public string Name { get; set; } public int Age { get; set; } public void SayHello() { Console.WriteLine($\"你好，我叫 {Name}，今年 {Age} 岁。\"); } } 创建对象： Person person = new Person { Name = \"Alice\", Age = 30 }; person.SayHello(); // 输出：你好，我叫 Alice，今年 30 岁。 4.2 继承\r继承允许子类复用父类的属性和方法。示例： public class Student : Person { public string StudentId { get; set; } } 从 Microsoft Learn 的银行系统示例中，InterestEarningAccount 和 LineOfCreditAccount 继承自 BankAccount，利率分别为 2% 和 7%，详见 https://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/tutorials/oop。 4.3 多态\r多态通过 virtual 和 override 实现方法重写。示例： public class Animal { public virtual void MakeSound() { Console.WriteLine(\"动物叫\"); } } public class Dog : Animal { public override void MakeSound() { Console.WriteLine(\"汪汪\"); } } 4.4 封装\r通过访问修饰符（如 public、private）控制成员访问，保护内部实现。 5. 高级主题\r初学者可逐步学习以下高级主题： 异常处理：使用 try-catch 捕获异常，例如： try { int result = 10 / 0; } catch (DivideByZeroException e) { Console.WriteLine(\"除数不能为零：\" + e.Message); } 文件 I/O：读写文件，使用 System.IO 命名空间。 LINQ：语言集成查询，用于数据操作，示例见官方文档。 异步编程：使用 async 和 await 处理异步任务，适合网络操作。 6. 进一步学习资源\r以下是推荐的学习资源： 官方文档：https://learn.microsoft.com/zh-cn/dotnet/csharp/，提供交互式教程和参考资料。 在线教程：https://www.runoob.com/csharp/csharp-tutorial.html，适合初学者，包含在线编译器。 书籍：推荐《C# 7.0 核心技术指南》和《Head First C#》，深入学习高级概念。 社区与动态：关注 C# 技术大会（如 2025 年会议，主题为智能创新）和 GitHub 仓库（如 https://github.com/dotnet/csharplang），了解最新动态。 https://learn.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-version-history。 ","date":"2024-08-05","objectID":"/csharp/basic/d14b1543-d65d-40cb-a7c4-f3bed1e0dfc6/:0:0","tags":["C#"],"title":"C#概述","uri":"/csharp/basic/d14b1543-d65d-40cb-a7c4-f3bed1e0dfc6/"}]