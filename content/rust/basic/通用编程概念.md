---
title: "通用编程概念"
date: 2025-08-14T15:57:54+0800
slug: "e0e61349-11a8-4cef-bb97-8bd12d84e769"
draft: true
author: 
  name: hao
  link: https://github.com/haochan1996
  email: espholychan@outllook.com
  avatar: https://avatars.githubusercontent.com/u/190246046?v=4
description:
keywords:
license:
comment: false
weight: 0
tags:
  - draft
categories:
  - draft
hiddenFromHomePage: false
hiddenFromSearch: false
hiddenFromRelated: false
hiddenFromFeed: false
summary:
resources:
  - name: featured-image
    src: featured-image.jpg
  - name: featured-image-preview
    src: featured-image-preview.jpg
toc: true
math: false
lightgallery: false
password:
message:
repost:
  enable: true
  url:
---

## 变量

在 Rust 中，变量默认是不可变的（**immutable**）。这意味着一旦你给变量赋了值，就不能再改变它。这种设计是 Rust 保证内存安全和并发安全的核心思想之一。

### 不可变变量（Immutable Variables）

当你声明一个变量时，如果不做任何特殊处理，它就是不可变的。

```rust
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);

    // 下面这行代码会导致编译错误，因为 x 是不可变的
    // x = 6;
}
```

编译器会报错，提示你不能对一个不可变的变量二次赋值。

### 可变变量（Mutable Variables）

如果你需要一个可以改变值的变量，需要在声明时使用 **`mut`** 关键字，使其变为可变（**mutable**）。

```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);

    // 现在可以修改 x 的值了
    x = 6;
    println!("The new value of x is: {}", x);
}
```

使用 `mut` 关键字的好处是，它能清晰地向代码的读者表明，这个变量的值在未来的某个时刻是可能被改变的。

-----

### 常量（Constants）

除了不可变变量，Rust 还有 **常量（constants）**。常量和不可变变量有些相似，但有几个关键区别：

1.  **关键字**: 声明常量需要使用 **`const`** 关键字，而不是 `let`。
2.  **可变性**: 常量总是不可变的，你不能给它们加上 `mut`。
3.  **命名规范**: 常量名通常使用全大写字母，并用下划线分隔单词，例如 `MAX_POINTS`。
4.  **表达式限制**: 常量只能被设置为常量表达式的结果，而不能是函数调用的结果或任何在运行时计算的值。

<!-- end list -->

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;

fn main() {
    println!("Three hours in seconds is: {}", THREE_HOURS_IN_SECONDS);
}
```

### 变量遮蔽（Shadowing）

Rust 允许你用一个同名的新变量来“遮蔽”（**shadow**）旧的变量。当新的变量被声明后，旧的变量就无法再访问了。

这和可变变量（`mut`）的区别在于：

  * **`mut`**: 修改的是同一个变量的值。
  * **Shadowing**: 创建了一个新的、同名的变量，它完全覆盖了旧的变量。

遮蔽的好处是，你可以改变变量的类型，而这是 `mut` 无法做到的。

```rust
fn main() {
    let x = 5;

    // 遮蔽 x
    let x = x + 1;

    {
        // 在内部作用域中再次遮蔽 x
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x); // 输出 12
    }

    println!("The value of x is: {}", x); // 输出 6
}
```

在这里，内部作用域的 `x` 遮蔽了外部的 `x`，但当内部作用域结束时，外部的 `x` 依然是有效且未被改变的。


## 数据类型

在 Rust 中，每个变量都有一个特定的数据类型。Rust 是一种**静态类型**语言，这意味着它在编译时就必须知道所有变量的类型。编译器通常能够根据你赋值的方式推断出类型，但有时你可能需要明确地标注类型。

### 基本数据类型 (Primitive Data Types)

Rust 的基本数据类型可以分为两大类：**标量 (Scalar)** 和 **复合 (Compound)**。

#### 1\. 标量类型 (Scalar Types)

标量类型代表一个单一的值。

  * **整数 (Integers)**
    整数类型用于存储没有小数部分的数字。Rust 提供了多种有符号（`i`）和无符号（`u`）的整数类型，其名称表示其位数。

      * **有符号整数**：`i8`, `i16`, `i32`, `i64`, `i128`
      * **无符号整数**：`u8`, `u16`, `u32`, `u64`, `u128`
      * **`isize` 和 `usize`**：这两种类型的大小取决于你的计算机架构。在 64 位系统上是 64 位，在 32 位系统上是 32 位。它们主要用于索引集合或进行内存地址运算。

    默认情况下，Rust 编译器会推断为 `i32`，这是最常见的类型。

    ```rust
    let x = 42;    // 编译器推断为 i32
    let y: u64 = 10000; // 显式类型标注
    ```

  * **浮点数 (Floating-Point Numbers)**
    浮点数用于存储带小数点的数字。Rust 有两种主要的浮点数类型：

      * **`f32`**：单精度浮点数
      * **`f64`**：双精度浮点数 (默认)

    <!-- end list -->

    ```rust
    let pi = 3.14; // 编译器推断为 f64
    let z: f32 = 2.718;
    ```

  * **布尔值 (Booleans)**
    布尔类型只有两个可能的值：`true` 和 `false`。它的大小为 1 个字节。

    ```rust
    let is_rust_fun = true;
    let is_raining: bool = false;
    ```

  * **字符 (Characters)**
    `char` 类型是 Rust 最基础的字母类型。它以 Unicode 标量值表示，可以存储比 ASCII 更丰富的字符，包括中文、日文、表情符号等。`char` 类型的大小为 4 个字节。

    ```rust
    let heart_eye = '😻';
    let a_letter = 'a';
    ```

#### 2\. 复合类型 (Compound Types)

复合类型可以将多个值组合成一个类型。

  * **元组 (Tuples)**
    元组可以将多个不同类型的值打包成一个复合类型。元组的长度是固定的，一旦声明就不能改变。

    ```rust
    let tup: (i32, f64, char) = (500, 6.4, 'Z');
    let (x, y, z) = tup; // 解构元组
    println!("The value of y is: {}", y);

    // 也可以通过索引访问元组元素
    let five_hundred = tup.0;
    ```

  * **数组 (Arrays)**
    数组用于存储一组相同类型的值。数组的长度是固定的。与元组不同，数组中的每个元素必须是相同的类型。

    ```rust
    let a = [1, 2, 3, 4, 5];
    let months = ["Jan", "Feb", "Mar"];
    let first = a[0];

    // 你也可以用 `[类型; 长度]` 的形式声明
    let b: [i32; 5] = [1, 2, 3, 4, 5];

    // 或者创建一个包含相同值的数组
    let c = [3; 5]; // 等价于 [3, 3, 3, 3, 3]
    ```

    访问数组元素时，如果索引超出范围，Rust 会在运行时报错（panic），从而避免了许多 C/C++ 等语言中的缓冲区溢出问题。

-----

### 类型转换 (Type Casting)

在 Rust 中，类型转换不是隐式进行的，你需要显式地进行转换。

```rust
let integer = 10;
let float = 5.5;

// 这行代码会报错，因为 i32 和 f64 不能直接相加
// let sum = integer + float;

let sum = integer as f64 + float; // 将 integer 转换为 f64
println!("Sum is: {}", sum);
```

通过这种方式，Rust 保证了类型安全，让你能清楚地知道代码中发生的类型转换。


