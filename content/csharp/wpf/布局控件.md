---
title: "布局控件"
date: 2025-08-05T01:26:27+0800
slug: "64d18599-4cf7-40aa-b995-9cc111f50bd3"
draft: false
author: 
  name: hobby
  link: https://github.com/haochan1996
  email: espholychan@outllook.com
  avatar: https://avatars.githubusercontent.com/u/190246046?v=4
description:
keywords:
license:
comment: false
weight: 0
tags:
  - WPF
  - C#
categories:
  - WPF
hiddenFromHomePage: false
hiddenFromSearch: false
hiddenFromRelated: false
hiddenFromFeed: false
summary:
resources:
  - name: featured-image
    src: featured-image.jpg
  - name: featured-image-preview
    src: featured-image-preview.jpg
toc: true
math: false
lightgallery: false
password:
message:
repost:
  enable: true
  url:
---

## 布局控件

WPF 布局控件（继承自 `Panel` 类, 除了`Border`）通过测量（Measure）和排列（Arrange）两个阶段自动计算子元素的位置与尺寸，支持动态适应窗口大小变化。布局控件通过 `Children` 属性容纳子元素（如按钮、文本框等），支持嵌套组合实现复杂界面。

|   **控件**    |                          布局方式                          |
| :-----------: | :--------------------------------------------------------: |
|    `Grid`     |           网格，根据自定义行和列来设置控件的布局           |
| `StackPanel`  |            堆叠，包含的元素在垂直或水平方向排列            |
|  `WrapPanel`  |                   流式布局，自动换行/列                    |
|  `DockPanel`  |                     边缘停靠+剩余填充                      |
|   `Canvas`    |           画布，内部元素以像素为单位绝对坐标定位           |
| `UniformGrid` |     均分网格，相当于Grid的简化版，每个单元格的大小相同     |
|   `Border`    | 装饰的控件，用于绘制边框及背景，在Border中只能有一个子控件 |

### Panel基类

Panel 是 Windows Presentation Foundation（WPF）中提供布局支持的所有元素的基类。 Panel派生元素用于在可扩展应用程序标记语言（XAML）和代码中定位和排列元素。 WPF 包含一套全面的派生面板实现，可实现许多复杂布局。 这些派生类公开了启用大多数标准用户界面（UI）方案的属性和方法。 无法找到满足其需求的子排列行为的开发人员可以通过重写 ArrangeOverride 和 MeasureOverride 方法创建新的布局。

所有[Panel](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.controls.panel)元素都支持由[FrameworkElement](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.frameworkelement)定义的基本大小调整和定位属性，包括[Height](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.frameworkelement.height)、[Width](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.frameworkelement.width)、[HorizontalAlignment](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.frameworkelement.horizontalalignment)、[VerticalAlignment](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.frameworkelement.verticalalignment)和[Margin](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.frameworkelement.margin)[LayoutTransform](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.frameworkelement.layouttransform)。 有关定位属性 [FrameworkElement](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.frameworkelement)的其他信息，请参阅 [对齐、边距和填充概述](https://learn.microsoft.com/zh-cn/dotnet/desktop/wpf/advanced/alignment-margins-and-padding-overview)。

[Panel](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.controls.panel) 公开了在理解和使用布局时极为重要的附加属性。 该[Background](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.controls.panel.background)属性用于用一个[Brush](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.media.brush)填充派生面板元素的边界之间的区域。 [Children](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.controls.panel.children) 表示由其 [Panel](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.controls.panel) 构成的元素的子集合。 [InternalChildren](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.controls.panel.internalchildren) 表示集合的内容 [Children](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.controls.panel.children) 以及数据绑定生成的成员。 两者都由父级[UIElementCollection](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.controls.uielementcollection)托管的子元素组成[Panel](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.controls.panel)。

面板还公开了一个 [Panel.ZIndex](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.controls.panel.zindex) 附加属性，该属性可用于在派生 [Panel](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.controls.panel)中实现分层顺序。 具有较高[Children](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.controls.panel.children)值的面板[Panel.ZIndex](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.controls.panel.zindex)集合的成员显示在值较低的[Panel.ZIndex](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.controls.panel.zindex)集合前面。 这对于面板特别有用，例如[Canvas](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.controls.canvas)[Grid](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.controls.grid)，允许子元素共享相同的坐标空间。

[Panel](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.controls.panel) 还定义了 [OnRender](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.controls.panel.onrender) 方法，该方法可用于替代默认 [Panel](https://learn.microsoft.com/zh-cn/dotnet/api/system.windows.controls.panel)呈现行为。

Panel提供了`GetZIndex`和`SetZIndex`方法成员，分别表示获取某个元素的Zindex顺序和设置某个元素的ZIndex顺序。

什么是ZIndex?这是Panel提供的一个**附加属性**。假如一个单行单列的Grid布局控件中有两个Button,正常情况下，这两个Button都会以撑满Grid的方式星现在Grid中，那么，到底哪一个Button在上面，哪一个Button在下面呢?就看这两个Button的`Panel.ZIndex`附加属性的值，值越大越在上面，而值较小的那个Button将被上面的Button遮盖，从而在视觉上，用户只能看到一个Button。

### Grid(网格布局)

通过行（`RowDefinitions`）和列（`ColumnDefinitions`）定义表格结构，支持单元格合并与动态尺寸调整。

**关键属性**：

- `Grid.Row` / `Grid.Column`：指定子元素位置。
- `RowSpan` / `ColumnSpan`：跨行/列。
- `ShowGridLines`: 是否显示网格线
- Grid的列宽与行高可采用固定、自动、按比例三种方式定义。
  1. 固定长度：值为一个确定的数字
  2. 自动长度：值为`Auto`，实际作用就是取实际控件所需的最小值
  3. 比例长度：
     - `*`表示占用剩余的全部宽度；两行都是`*`，将平分剩余宽度;
     - 一个2`*`，一个`*`，则前者占剩余全部宽度的2/3，后者占1/3;

示例：

```xaml
<Grid>
    <Grid.RowDefinitions>   
        <RowDefinition Height="40"></RowDefinition> 
        <RowDefinition Height="Auto"></RowDefinition>   
        <RowDefinition Height="2*"></RowDefinition>    
        <RowDefinition Height="*"></RowDefinition>   
    </Grid.RowDefinitions>  
    <Button Grid.Row="0" Content="Button 1"></Button> 
    <Button Grid.Row="1" Content="Button 2"></Button>
    <Button Grid.Row="2" Content="Button 3"></Button> 
    <Button Grid.Row="3" Content="Button 4"></Button>
</Grid>
```

效果：

<img src="https://blog-1301697820.cos.ap-guangzhou.myqcloud.com/blog/805533a8161f36e18eeafe43727731e7.png" alt="img" style="zoom: 50%;" />

### StackPanel(堆叠布局)

子元素按单一方向（`Orientation="Vertical"` 或 `Horizontal"`）线性排列，不自动换行。**默认方向**是垂直排列（`Orientation="Vertical"`），子元素从上到下堆叠。如果要设置**水平排列**，设置 `Orientation="Horizontal"`，子元素从左到右排列。垂直布局时，子元素**宽度**默认拉伸至 StackPanel 的宽度，高度由内容决定（或显式设置）。水平布局时，子元素**高度**拉伸至 StackPanel 高度，宽度由内容决定。

StackPanel关键属性如下：

|       **属性**        |                           **说明**                           |           **示例值**           |
| :-------------------: | :----------------------------------------------------------: | :----------------------------: |
|     `Orientation`     |         排列方向：`Vertical`（默认）或 `Horizontal`          |   `Orientation="Horizontal"`   |
|       `Margin`        |                容器外间距，控制与父容器的距离                |         `Margin="10"`          |
|       `Padding`       |            容器内边距，控制子元素与容器边界的距离            |         `Padding="5"`          |
|     `Background`      |               背景色（未设置时不响应鼠标事件）               |    `Background="LightGray"`    |
| `HorizontalAlignment` | 容器在父容器中的水平对齐方式（`Left`/`Center`/`Right`/`Stretch`） | `HorizontalAlignment="Center"` |
|  `VerticalAlignment`  | 容器在父容器中的垂直对齐方式（`Top`/`Center`/`Bottom`/`Stretch`） |   `VerticalAlignment="Top"`    |

#### 布局嵌套

StackPanel 可嵌套其他容器（如 `Grid`、嵌套的 `StackPanel`）实现复杂结构

```xaml
<!-- 垂直布局嵌套水平布局 -->
<StackPanel Orientation="Vertical">
    <TextBlock Text="用户登录"/>
    <StackPanel Orientation="Horizontal"> <!-- 水平布局 -->
        <TextBlock Text="用户名：" VerticalAlignment="Center"/>
        <TextBox Width="200"/>
    </StackPanel>
    <Button Content="提交"/>
</StackPanel>
```

#### **滚动支持**

通过 `ScrollViewer` 包裹 StackPanel 解决内容溢出问题

```xaml
<ScrollViewer Height="150">
    <StackPanel>
        <Button Content="Item 1" Height="40"/>
        <!-- 更多子元素 -->
    </StackPanel>
</ScrollViewer>
```

#### **动态操作子元素**

在代码中动态添加/删除子元素

```c#
// 添加按钮
private void AddButton_Click(object sender, RoutedEventArgs e) {
    Button newBtn = new Button { Content = "New Button" };
    stackPanel.Children.Add(newBtn);
}
// 删除最后一个按钮
private void RemoveButton_Click(object sender, RoutedEventArgs e) {
    if (stackPanel.Children.Count > 0)
        stackPanel.Children.RemoveAt(stackPanel.Children.Count - 1);
}
```

